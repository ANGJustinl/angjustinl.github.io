{"meta":{"title":"ÊòÇÁöÑÊ∑±ÊûóÂ∞èÂ±ã","subtitle":"Ê¨¢Ëøé~","description":"my_site","author":"ANGJustinl","url":"http://www.angforever.top","root":"/"},"pages":[{"title":"FRIENDS","date":"2023-01-07T02:48:49.101Z","updated":"2023-01-07T02:48:49.101Z","comments":true,"path":"PY.html","permalink":"http://www.angforever.top/PY.html","excerpt":"","text":"U ARE MY BEST FRIEND ÂèãÊÉÖÈìæÊé• Ê∑ªÂä†ÂèãÈìæËØ∑ÁïôË®Ä ÂêçÁß∞ÔºöYOUR NAME PLZ‰ªãÁªçÔºöINTRODUCTIONÈìæÊé•ÔºöLINKSLOGOÔºöLINK OF LOGO ÈúÄË¶ÅÊõ¥Êñ∞Â§¥ÂÉèÊàñËÄÖÈìæÊé•ËØ∑ÁïôË®ÄÔºåÊúâÊ≤°ÊúâÊó∂Èó¥ÊàëÈÉΩ‰ºöÂ§ÑÁêÜÁöÑ"},{"title":"ÊòÇÁöÑÊ∑±ÊûóÂ∞èÂ±ã","date":"2023-01-12T06:42:43.622Z","updated":"2023-01-07T02:55:02.429Z","comments":true,"path":"about.html","permalink":"http://www.angforever.top/about.html","excerpt":"","text":"ÂçöÂÆ¢‰∫ã‰ª∂ËΩ¥ 2023Âπ¥01Êúà5Êó• - Âú®Hexo‰∏äËØïÈÉ®ÁΩ≤ ÂèØ‰ª•Âú®Ëøô‰∫õÂú∞ÊñπÊâæÂà∞Êàë links üîóMusic üé∂Justinlyu - Áî®Êà∑ - ÁΩëÊòì‰∫ëÈü≥‰πê (163.com) Open Source üîåANGJustinl (ÊòÇ) (github.com) bilibili üìπÊòÇ (bilibili.com) Steam üéÆÔ∏èANGJustinl Âø´Êù•ÁªôÊàëÁïôË®Ä"},{"title":"ÊñáÁ´†ÂΩíÊ°£","date":"2023-01-05T07:03:59.183Z","updated":"2023-01-05T03:47:17.290Z","comments":true,"path":"archive.html","permalink":"http://www.angforever.top/archive.html","excerpt":"","text":""},{"title":"","date":"2023-01-21T11:54:53.972Z","updated":"2022-02-03T08:35:31.083Z","comments":true,"path":"FIREWORKS/README.html","permalink":"http://www.angforever.top/FIREWORKS/README.html","excerpt":"","text":"ÁÉüËä±Ê®°ÊãüÂô®Ê≥®ÊÑèÔºöÊ≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ Êàë‰ªÖ‰ΩúÁøªËØëÂ§ÑÁêÜ‰ª•ÂèäÂÖ∂‰ªñ‰ºòÂåñ Demo 1Ôºöhttps://nianbroken.github.io/Firework_Simulator/ Demo 2Ôºöhttps://fireworks.nianbroken.top/ Â±ïÁ§∫Âõæ Ëã•ÊúâÁøªËØëÈîôËØëÊàñÂÖ∂‰ªñÈóÆÈ¢òÔºåËØ∑Âú®IssuesÊèê‰∫§„ÄÇ"},{"title":"","date":"2023-01-21T11:54:53.785Z","updated":"2022-01-31T02:47:32.000Z","comments":true,"path":"FIREWORKS/index.html","permalink":"http://www.angforever.top/FIREWORKS/index.html","excerpt":"","text":"ÁÉüËä±Ê®°ÊãüÂô® Âä†ËΩΩ‰∏≠ Ê≠£Âú®Ë£ÖÈÖçÁÉüËä± ËÆæÁΩÆ Ëã•ÊÉ≥‰∫ÜËß£Êõ¥Â§ö‰ø°ÊÅØ ËØ∑ÁÇπÂáª‰ªªÊÑèÊ†áÁ≠æ ÁÉüËä±Á±ªÂûã ÁÉüËä±Â§ßÂ∞è ÁîªË¥® ÁÖß‰∫ÆÂ§©Á©∫ Áº©Êîæ Ëá™Âä®ÊîæÁÉüËä± ÂêåÊó∂ÊîæÊõ¥Â§öÁöÑÁÉüËä± ÈöêËóèÊéßÂà∂ÊåâÈíÆ ÂÖ®Â±è ‰øùÁïôÁÉüËä±ÁöÑÁÅ´Ëä± ÊÇ®ÁöÑIPÔºö document.write(returnCitySN[\"cip\"]) var mydate = new Date(); document.writeln(\"COPYRIGHT&nbsp;&copy;&nbsp;2021 - \" + mydate.getFullYear() + '&nbsp;Á¢éÂøµ_NIANALL&nbsp;RIGHTS&nbsp;RESERVED'); Â∏åÊúõ‰Ω†ÊâÄÊúâÁöÑ‰∏çÂπ∏ ÈÉΩÂèØ‰ª•Âú®Êú¨Á´ôÁöÑÂ£∞Â£∞Èû≠ÁÇÆ‰∏≠ÁªìÊùü document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1280819439'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1280819439' type='text/javascript'%3E%3C/script%3E\")); ÂÖ≥Èó≠"},{"title":"","date":"2023-01-21T11:54:54.066Z","updated":"2022-02-03T08:53:32.694Z","comments":true,"path":"FIREWORKS/style.css","permalink":"http://www.angforever.top/FIREWORKS/style.css","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ * { position: relative; box-sizing: border-box; } html, body { height: 100%; } html { background-color: #000; } body { overflow: hidden; color: rgba(255, 255, 255, 0.5); font-family: \"Russo One\", arial, sans-serif; line-height: 1.25; letter-spacing: 0.06em; } .hide { opacity: 0; visibility: hidden; } .remove { display: none !important; } .blur { filter: blur(12px); } .container { height: 100%; display: flex; justify-content: center; align-items: center; } .loading-init { width: 100%; align-self: center; text-align: center; text-transform: uppercase; } .loading-init__header { font-size: 2.2em; } .loading-init__status { margin-top: 1em; font-size: 0.8em; opacity: 0.75; } .stage-container { overflow: hidden; box-sizing: initial; border: 1px solid #222; margin: -1px; } @media (max-width: 840px) { .stage-container { border: none; margin: 0; } } .canvas-container { width: 100%; height: 100%; transition: filter 0.3s; } .canvas-container canvas { position: absolute; mix-blend-mode: lighten; transform: translateZ(0); } .controls { position: absolute; top: 0; width: 100%; padding-bottom: 50px; display: flex; justify-content: space-between; transition: opacity 0.3s, visibility 0.3s; } @media (min-width: 840px) { .controls { visibility: visible; } .controls.hide:hover { opacity: 1; } } .menu { position: absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: rgba(0, 0, 0, 0.42); transition: opacity 0.3s, visibility 0.3s; } .menu__inner-wrap { display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; top: 0; bottom: 0; left: 0; right: 0; transition: opacity 0.3s; } .menu__header { margin-top: auto; margin-bottom: 8px; padding-top: 16px; font-size: 2em; text-transform: uppercase; } .menu__subheader { margin-bottom: auto; padding-bottom: 12px; font-size: 0.86em; opacity: 0.8; } .menu form { width: 100%; max-width: 400px; padding: 0 10px; overflow: auto; -webkit-overflow-scrolling: touch; } .menu .form-option { display: flex; align-items: center; margin: 16px 0; transition: opacity 0.3s; } .menu .form-option label { display: block; width: 50%; padding-right: 12px; text-align: right; text-transform: uppercase; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .menu .form-option--select select { display: block; width: 50%; height: 30px; font-size: 1rem; font-family: \"Russo One\", arial, sans-serif; color: rgba(255, 255, 255, 0.5); letter-spacing: 0.06em; background-color: transparent; border: 1px solid rgba(255, 255, 255, 0.5); } .menu .form-option--select select option { background-color: black; } .menu .form-option--checkbox input { display: block; width: 26px; height: 26px; margin: 0; opacity: 0.5; } @media (max-width: 840px) { .menu .form-option select, .menu .form-option input { outline: none; } } .close-menu-btn { position: absolute; top: 0; right: 0; } /*Language translation of this project into Chinese by Nianbroken*/ .btn { opacity: 0.16; width: 50px; height: 50px; display: flex; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: default; transition: opacity 0.3s; } .btn--bright { opacity: 0.5; } @media (min-width: 840px) { .btn:hover { opacity: 0.32; } .btn--bright:hover { opacity: 0.75; } } .btn svg { display: block; margin: auto; } .credits { margin-top: auto; margin-bottom: 10px; padding-top: 6px; font-size: 0.8em; opacity: 0.75; text-align: center; } .credits a { color: rgba(255, 255, 255, 0.5); text-decoration: none; } .credits a:hover, .credits a:active { color: rgba(255, 255, 255, 0.75); text-decoration: underline; } .help-modal { display: flex; justify-content: center; align-items: center; position: fixed; top: 0; bottom: 0; left: 0; right: 0; visibility: hidden; transition-property: visibility; transition-duration: 0.25s; } .help-modal__overlay { position: absolute; top: 0; bottom: 0; left: 0; right: 0; opacity: 0; transition-property: opacity; transition-timing-function: ease-in; transition-duration: 0.25s; } /*Language translation of this project into Chinese by Nianbroken*/ .help-modal__dialog { display: flex; flex-direction: column; align-items: center; max-width: 400px; max-height: calc(100vh - 100px); margin: 10px; padding: 20px; border-radius: 0.3em; background-color: rgba(0, 0, 0, 0.4); opacity: 0; transform: scale(0.9, 0.9); transition-property: opacity, transform; transition-timing-function: ease-in; transition-duration: 0.25s; } @media (min-width: 840px) { .help-modal__dialog { font-size: 1.25rem; max-width: 500px; } } .help-modal__header { font-size: 1.75em; text-transform: uppercase; text-align: center; } .help-modal__body { overflow-y: auto; -webkit-overflow-scrolling: touch; margin: 1em 0; padding: 1em 0; border-top: 1px solid rgba(255, 255, 255, 0.25); border-bottom: 1px solid rgba(255, 255, 255, 0.25); line-height: 1.5; color: rgba(255, 255, 255, 0.75); } .help-modal__close-btn { flex-shrink: 0; outline: none; border: none; border-radius: 2px; padding: 0.25em 0.75em; margin-top: 0.36em; font-family: \"Russo One\", arial, sans-serif; font-size: 1em; color: rgba(255, 255, 255, 0.5); text-transform: uppercase; letter-spacing: 0.06em; background-color: rgba(255, 255, 255, 0.25); transition: color 0.3s, background-color 0.3s; } .help-modal__close-btn:hover, .help-modal__close-btn:active, .help-modal__close-btn:focus { color: #FFF; background-color: #09F; } .help-modal.active { visibility: visible; transition-duration: 0.4s; } .help-modal.active .help-modal__overlay { opacity: 1; transition-timing-function: ease-out; transition-duration: 0.4s; } .help-modal.active .help-modal__dialog { opacity: 1; transform: scale(1, 1); transition-timing-function: ease-out; transition-duration: 0.4s; }"},{"title":"","date":"2023-01-21T11:54:52.097Z","updated":"2022-02-03T08:49:50.440Z","comments":true,"path":"js/MyMath.js","permalink":"http://www.angforever.top/js/MyMath.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ const MyMath = (function MyMathFactory(Math) { const MyMath = {}; // degree/radian conversion constants MyMath.toDeg = 180 / Math.PI; MyMath.toRad = Math.PI / 180; MyMath.halfPI = Math.PI / 2; MyMath.twoPI = Math.PI * 2; // Pythagorean Theorem distance calculation MyMath.dist = (width, height) => { return Math.sqrt(width * width + height * height); }; // Pythagorean Theorem point distance calculation // Same as above, but takes coordinates instead of dimensions. // The language of this project was translated into Chinese by Nianbroken MyMath.pointDist = (x1, y1, x2, y2) => { const distX = x2 - x1; const distY = y2 - y1; return Math.sqrt(distX * distX + distY * distY); }; // Returns the angle (in radians) of a 2D vector MyMath.angle = (width, height) => ( MyMath.halfPI + Math.atan2(height, width) ); // Returns the angle (in radians) between two points // Same as above, but takes coordinates instead of dimensions. MyMath.pointAngle = (x1, y1, x2, y2) => ( MyMath.halfPI + Math.atan2(y2 - y1, x2 - x1) ); // Splits a speed vector into x and y components (angle needs to be in radians) MyMath.splitVector = (speed, angle) => ({ x: Math.sin(angle) * speed, y: -Math.cos(angle) * speed }); // Generates a random number between min (inclusive) and max (exclusive) MyMath.random = (min, max) => Math.random() * (max - min) + min; // Generates a random integer between and possibly including min and max values MyMath.randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min; // Returns a random element from an array, or simply the set of provided arguments when called MyMath.randomChoice = function randomChoice(choices) { if (arguments.length === 1 && Array.isArray(choices)) { return choices[(Math.random() * choices.length) | 0]; } return arguments[(Math.random() * arguments.length) | 0]; }; // Clamps a number between min and max values MyMath.clamp = function clamp(num, min, max) { return Math.min(Math.max(num, min), max); }; return MyMath; })(Math);"},{"title":"","date":"2023-01-21T11:54:52.410Z","updated":"2022-02-03T08:52:06.384Z","comments":true,"path":"js/Stage.js","permalink":"http://www.angforever.top/js/Stage.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ const Ticker = (function TickerFactory(window) { 'use strict'; const Ticker = {}; // public // will call function reference repeatedly once registered, passing elapsed time and a lag multiplier as parameters Ticker.addListener = function addListener(callback) { if (typeof callback !== 'function') throw('Ticker.addListener() requires a function reference passed for a callback.'); listeners.push(callback); // start frame-loop lazily if (!started) { started = true; queueFrame(); } }; // private let started = false; let lastTimestamp = 0; let listeners = []; // queue up a new frame (calls frameHandler) function queueFrame() { if (window.requestAnimationFrame) { requestAnimationFrame(frameHandler); } else { webkitRequestAnimationFrame(frameHandler); } } function frameHandler(timestamp) { let frameTime = timestamp - lastTimestamp; lastTimestamp = timestamp; // make sure negative time isn't reported (first frame can be whacky) if (frameTime < 0) { frameTime = 17; } // - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal') else if (frameTime > 68) { frameTime = 68; } // fire custom listeners listeners.forEach(listener => listener.call(window, frameTime, frameTime / 16.6667)); // always queue another frame queueFrame(); } return Ticker; })(window); const Stage = (function StageFactory(window, document, Ticker) { 'use strict'; // Track touch times to prevent redundant mouse events. let lastTouchTimestamp = 0; // Stage constructor (canvas can be a dom node, or an id string) function Stage(canvas) { if (typeof canvas === 'string') canvas = document.getElementById(canvas); // canvas and associated context references this.canvas = canvas; this.ctx = canvas.getContext('2d'); // Prevent gestures on stages (scrolling, zooming, etc) this.canvas.style.touchAction = 'none'; // physics speed multiplier: allows slowing down or speeding up simulation (must be manually implemented in physics layer) this.speed = 1; // devicePixelRatio alias (should only be used for rendering, physics shouldn't care) // avoids rendering unnecessary pixels that browser might handle natively via CanvasRenderingContext2D.backingStorePixelRatio // Language translation of this project into Chinese by Nianbroken this.dpr = Stage.disableHighDPI ? 1 : ((window.devicePixelRatio || 1) / (this.ctx.backingStorePixelRatio || 1)); // canvas size in DIPs and natural pixels this.width = canvas.width; this.height = canvas.height; this.naturalWidth = this.width * this.dpr; this.naturalHeight = this.height * this.dpr; // size canvas to match natural size if (this.width !== this.naturalWidth) { this.canvas.width = this.naturalWidth; this.canvas.height = this.naturalHeight; this.canvas.style.width = this.width + 'px'; this.canvas.style.height = this.height + 'px'; } // To any known illigitimate users... const badDomains = ['bla'+'ckdiam'+'ondfirew'+'orks'+'.de']; const hostname = document.location.hostname; if (badDomains.some(d => hostname.includes(d))) { const delay = 60000 * 3; // 3 minutes setTimeout(() => { const html = ` `+` `+` bo`+`dy { bac`+`kgrou`+`nd-colo`+`r: #000;`+` padd`+`ing: `+`20px; text-`+`align:`+` center; col`+`or: `+`#ddd`+`; mi`+`n-he`+`ight`+`: 10`+`0vh;`+` dis`+`play`+`: fl`+`ex; `+`flex`+`-dir`+`ecti`+`on: `+`colu`+`mn; `+`just`+`ify-`+`cont`+`ent:`+` cen`+`ter;`+` ali`+`gn-i`+`tems`+`: ce`+`nter`+`; ov`+`erfl`+`ow: `+`visi`+`ble;`+` } `+` `+` h1 `+`{ fo`+`nt-s`+`ize:`+` 1.2`+`em;`+`} `+` `+`p { `+`marg`+`in-t`+`op: `+`1em;`+` max`+`-wid`+`th: `+`36em`+`; } `+` `+` a `+`{ co`+`lor:`+` #ff`+`f; tex`+`t-dec`+`orati`+`on: u`+`nderl`+`ine; }`+` `+` `+` `+``+`Hi! `+`Sorr`+`y to`+` int`+`erru`+`pt t`+`he f`+`irew`+`orks`+`. `+` `+`M`+`y na`+`me i`+`s Ca`+`leb.`+` Des`+`pite`+` wha`+`t th`+`is s`+`ite `+`clai`+`ms, `+`I de`+`sign`+`ed a`+`nd b`+`uilt`+` thi`+`s so`+`ftwa`+`re m`+`ysel`+`f. I`+`'ve `+`spen`+`t a `+`coup`+`le h`+`undr`+`ed h`+`ours`+` of `+`my o`+`wn t`+`ime, `+`over`+` tw`+`o ye`+`ars, `+`maki`+`ng i`+`t. `+` `+`T`+`he o`+`wner`+` of `+`this`+` sit`+`e cl`+`earl`+`y do`+`esn'`+`t re`+`spec`+`t my`+` wor`+`k, a`+`nd h`+`as l`+`abel`+`ed i`+`t as`+` the`+`ir o`+`wn. `+` `+` `+`If y`+`ou w`+`ere `+`enjo`+`ying`+` the`+` sho`+`w, p`+`leas`+`e ch`+`eck `+`out `+``+`my&n`+`bsp;`+`offi`+`cial`+`&nbs`+`p;ve`+`rsio`+`n&nb`+`sp;h`+`ere!`+` `+` `+` I`+`f you`+`'re th`+`e ow`+`ner, cont`+`act m`+`e`+`.`; document.body.innerHTML = html; }, delay); } Stage.stages.push(this); // event listeners (note that 'ticker' is also an option, for frame events) this._listeners = { // canvas resizing resize: [], // pointer events pointerstart: [], pointermove: [], pointerend: [], lastPointerPos: {x:0, y:0} }; } // track all Stage instances Stage.stages = []; // allow turning off high DPI support for perf reasons (enabled by default) // Note: MUST be set before Stage construction. // Each stage tracks its own DPI (initialized at construction time), so you can effectively allow some Stages to render high-res graphics but not others. // Language translation of this project into Chinese by Nianbroken Stage.disableHighDPI = false; // events Stage.prototype.addEventListener = function addEventListener(event, handler) { try { if (event === 'ticker') { Ticker.addListener(handler); }else{ this._listeners[event].push(handler); } } catch (e) { throw('Invalid Event') } }; Stage.prototype.dispatchEvent = function dispatchEvent(event, val) { const listeners = this._listeners[event]; if (listeners) { listeners.forEach(listener => listener.call(this, val)); }else{ throw('Invalid Event'); } }; // resize canvas Stage.prototype.resize = function resize(w, h) { this.width = w; this.height = h; this.naturalWidth = w * this.dpr; this.naturalHeight = h * this.dpr; this.canvas.width = this.naturalWidth; this.canvas.height = this.naturalHeight; this.canvas.style.width = w + 'px'; this.canvas.style.height = h + 'px'; this.dispatchEvent('resize'); }; // utility function for coordinate space conversion Stage.windowToCanvas = function windowToCanvas(canvas, x, y) { const bbox = canvas.getBoundingClientRect(); return { x: (x - bbox.left) * (canvas.width / bbox.width), y: (y - bbox.top) * (canvas.height / bbox.height) }; }; // handle interaction Stage.mouseHandler = function mouseHandler(evt) { // Prevent mouse events from firing immediately after touch events if (Date.now() - lastTouchTimestamp < 500) { return; } let type = 'start'; if (evt.type === 'mousemove') { type = 'move'; }else if (evt.type === 'mouseup') { type = 'end'; } Stage.stages.forEach(stage => { const pos = Stage.windowToCanvas(stage.canvas, evt.clientX, evt.clientY); stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr); }); }; Stage.touchHandler = function touchHandler(evt) { lastTouchTimestamp = Date.now(); // Set generic event type let type = 'start'; if (evt.type === 'touchmove') { type = 'move'; }else if (evt.type === 'touchend') { type = 'end'; } // Dispatch \"pointer events\" for all changed touches across all stages. Stage.stages.forEach(stage => { // Safari doesn't treat a TouchList as an iteratable, hence Array.from() for (let touch of Array.from(evt.changedTouches)) { let pos; if (type !== 'end') { pos = Stage.windowToCanvas(stage.canvas, touch.clientX, touch.clientY); stage._listeners.lastPointerPos = pos; // before touchstart event, fire a move event to better emulate cursor events // Language translation of this project into Chinese by Nianbroken if (type === 'start') stage.pointerEvent('move', pos.x / stage.dpr, pos.y / stage.dpr); }else{ // on touchend, fill in position information based on last known touch location pos = stage._listeners.lastPointerPos; } stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr); } }); }; // dispatch a normalized pointer event on a specific stage Stage.prototype.pointerEvent = function pointerEvent(type, x, y) { // build event oject to dispatch const evt = { type: type, x: x, y: y }; // whether pointer event was dispatched over canvas element evt.onCanvas = (x >= 0 && x = 0 && y"},{"title":"","date":"2023-01-14T11:57:23.830Z","updated":"2023-01-14T11:57:23.830Z","comments":true,"path":"js/colorful.js","permalink":"http://www.angforever.top/js/colorful.js","excerpt":"","text":"Title (function (name, factory) { if (typeof window === \"object\") { window[name] = factory(); } })(\"Ribbons\", function () { var _w = window, _b = document.body, _d = document.documentElement; var random = function () { if (arguments.length === 1) { if (Array.isArray(arguments[0])) { var index = Math.round(random(0, arguments[0].length - 1)); return arguments[0][index]; } return random(0, arguments[0]); } else if (arguments.length === 2) { return Math.random() * (arguments[1] - arguments[0]) + arguments[0]; } return 0; }; var screenInfo = function (e) { var width = Math.max(0, _w.innerWidth || _d.clientWidth || _b.clientWidth || 0), height = Math.max(0, _w.innerHeight || _d.clientHeight || _b.clientHeight || 0), scrollx = Math.max(0, _w.pageXOffset || _d.scrollLeft || _b.scrollLeft || 0) - (_d.clientLeft || 0), scrolly = Math.max(0, _w.pageYOffset || _d.scrollTop || _b.scrollTop || 0) - (_d.clientTop || 0); return { width: width, height: height, ratio: width / height, centerx: width / 2, centery: height / 2, scrollx: scrollx, scrolly: scrolly }; }; var mouseInfo = function (e) { var screen = screenInfo(e), mousex = e ? Math.max(0, e.pageX || e.clientX || 0) : 0, mousey = e ? Math.max(0, e.pageY || e.clientY || 0) : 0; return { mousex: mousex, mousey: mousey, centerx: mousex - screen.width / 2, centery: mousey - screen.height / 2 }; }; var Point = function (x, y) { this.x = 0; this.y = 0; this.set(x, y); }; Point.prototype = { constructor: Point, set: function (x, y) { this.x = x || 0; this.y = y || 0; }, copy: function (point) { this.x = point.x || 0; this.y = point.y || 0; return this; }, multiply: function (x, y) { this.x *= x || 1; this.y *= y || 1; return this; }, divide: function (x, y) { this.x /= x || 1; this.y /= y || 1; return this; }, add: function (x, y) { this.x += x || 0; this.y += y || 0; return this; }, subtract: function (x, y) { this.x -= x || 0; this.y -= y || 0; return this; }, clampX: function (min, max) { this.x = Math.max(min, Math.min(this.x, max)); return this; }, clampY: function (min, max) { this.y = Math.max(min, Math.min(this.y, max)); return this; }, flipX: function () { this.x *= -1; return this; }, flipY: function () { this.y *= -1; return this; } }; var Factory = function (options) { this._canvas = null; this._context = null; this._sto = null; this._width = 0; this._height = 0; this._scroll = 0; this._ribbons = []; this._options = { colorSaturation: \"80%\", colorBrightness: \"60%\", colorAlpha: 0.65, colorCycleSpeed: 6, verticalPosition: \"center\", horizontalSpeed: 200, ribbonCount: 4, strokeSize: 0, parallaxAmount: -0.5, animateSections: true }; this._onDraw = this._onDraw.bind(this); this._onResize = this._onResize.bind(this); this._onScroll = this._onScroll.bind(this); this.setOptions(options); this.init(); }; Factory.prototype = { constructor: Factory, setOptions: function (options) { if (typeof options === \"object\") { for (var key in options) { if (options.hasOwnProperty(key)) { this._options[key] = options[key]; } } } }, init: function () { try { this._canvas = document.createElement(\"canvas\"); this._canvas.style[\"display\"] = \"block\"; this._canvas.style[\"position\"] = \"fixed\"; this._canvas.style[\"margin\"] = \"0\"; this._canvas.style[\"padding\"] = \"0\"; this._canvas.style[\"border\"] = \"0\"; this._canvas.style[\"outline\"] = \"0\"; this._canvas.style[\"left\"] = \"0\"; this._canvas.style[\"top\"] = \"0\"; this._canvas.style[\"width\"] = \"100%\"; this._canvas.style[\"height\"] = \"100%\"; this._canvas.style[\"z-index\"] = \"-1\"; this._canvas.style[\"background-color\"] = \"#1f1f1f\"; this._canvas.id = \"bgCanvas\"; this._onResize(); this._context = this._canvas.getContext(\"2d\"); this._context.clearRect(0, 0, this._width, this._height); this._context.globalAlpha = this._options.colorAlpha; // ËøôÈáåÂèØ‰ª•ËÆæÁΩÆÊòØÂê¶ÈöèÁùÄÁ™óÂè£ÁöÑÊªöÂä®ËÄåÊªöÂä® window.addEventListener(\"resize\", this._onResize); window.addEventListener(\"scroll\", this._onScroll); // ËøôÈáåËÆæÁΩÆÊ∑ªÂä†ÁöÑ‰ΩçÁΩÆ var body_ = document.getElementsByTagName('body')[0]; body_.appendChild(this._canvas); } catch (e) { console.warn(\"Canvas Context Error: \" + e.toString()); return; } this._onDraw(); }, addRibbon: function () { var dir = Math.round(random(1, 9)) > 5 ? \"right\" : \"left\", stop = 1000, hide = 200, min = 0 - hide, max = this._width + hide, movex = 0, movey = 0, startx = dir === \"right\" ? min : max, starty = Math.round(random(0, this._height)); if (/^(top|min)$/i.test(this._options.verticalPosition)) { starty = 0 + hide; } else if (/^(middle|center)$/i.test(this._options.verticalPosition)) { starty = this._height / 2; } else if (/^(bottom|max)$/i.test(this._options.verticalPosition)) { starty = this._height - hide; } var ribbon = [], point1 = new Point(startx, starty), point2 = new Point(startx, starty), point3 = null, color = Math.round(random(0, 360)), delay = 0; while (true) { if (stop = max) break; } else if (dir === \"left\") { point3.subtract(movex, movey); if (point2.x = 1 && section.alpha"},{"title":"","date":"2023-01-21T11:54:52.019Z","updated":"2022-02-03T08:49:41.312Z","comments":true,"path":"js/fscreen.js","permalink":"http://www.angforever.top/js/fscreen.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ (function(global) { 'use strict'; var key = { fullscreenEnabled: 0, fullscreenElement: 1, requestFullscreen: 2, exitFullscreen: 3, fullscreenchange: 4, fullscreenerror: 5 }; var webkit = ['webkitFullscreenEnabled', 'webkitFullscreenElement', 'webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitfullscreenchange', 'webkitfullscreenerror']; var moz = ['mozFullScreenEnabled', 'mozFullScreenElement', 'mozRequestFullScreen', 'mozCancelFullScreen', 'mozfullscreenchange', 'mozfullscreenerror']; var ms = ['msFullscreenEnabled', 'msFullscreenElement', 'msRequestFullscreen', 'msExitFullscreen', 'MSFullscreenChange', 'MSFullscreenError']; // so it doesn't throw if no window or document // The language of this project was translated into Chinese by Nianbroken var doc = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {}; var vendor = 'fullscreenEnabled' in doc && Object.keys(key) || webkit[0] in doc && webkit || moz[0] in doc && moz || ms[0] in doc && ms || []; var fscreen = { requestFullscreen: function requestFullscreen(element) { return element[vendor[key.requestFullscreen]](); }, requestFullscreenFunction: function requestFullscreenFunction(element) { return element[vendor[key.requestFullscreen]]; }, get exitFullscreen() { return doc[vendor[key.exitFullscreen]].bind(doc); }, addEventListener: function addEventListener(type, handler, options) { return doc.addEventListener(vendor[key[type]], handler, options); }, removeEventListener: function removeEventListener(type, handler) { return doc.removeEventListener(vendor[key[type]], handler); }, get fullscreenEnabled() { return Boolean(doc[vendor[key.fullscreenEnabled]]); }, set fullscreenEnabled(val) {}, get fullscreenElement() { return doc[vendor[key.fullscreenElement]]; }, set fullscreenElement(val) {}, get onfullscreenchange() { return doc[('on' + vendor[key.fullscreenchange]).toLowerCase()]; }, set onfullscreenchange(handler) { return doc[('on' + vendor[key.fullscreenchange]).toLowerCase()] = handler; }, get onfullscreenerror() { return doc[('on' + vendor[key.fullscreenerror]).toLowerCase()]; }, set onfullscreenerror(handler) { return doc[('on' + vendor[key.fullscreenerror]).toLowerCase()] = handler; } }; global.fscreen = fscreen; })(window);"},{"title":"","date":"2023-01-21T11:54:52.222Z","updated":"2022-02-03T08:59:15.816Z","comments":true,"path":"js/script.js","permalink":"http://www.angforever.top/js/script.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ 'use strict'; console.clear(); // This is a prime example of what starts out as a simple project // and snowballs way beyond its intended size. It's a little clunky // reading/working on this single file, but here it is anyways :) const IS_MOBILE = window.innerWidth 800; const IS_HEADER = IS_DESKTOP && window.innerHeight < 300; // Detect high end devices. This will be a moving target. const IS_HIGH_END_DEVICE = (() => { const hwConcurrency = navigator.hardwareConcurrency; if (!hwConcurrency) { return false; } // Large screens indicate a full size computer, which often have hyper threading these days. // So a quad core desktop machine has 8 cores. We'll place a higher min threshold there. const minCount = window.innerWidth = minCount; })(); // Prevent canvases from getting too large on ridiculous screen sizes. // 8K - can restrict this if needed const MAX_WIDTH = 7680; const MAX_HEIGHT = 4320; const GRAVITY = 0.9; // Acceleration in px/s let simSpeed = 1; function getDefaultScaleFactor() { if (IS_MOBILE) return 0.9; if (IS_HEADER) return 0.75; return 1; } // Width/height values that take scale into account. // USE THESE FOR DRAWING POSITIONS let stageW, stageH; // All quality globals will be overwritten and updated via `configDidUpdate`. let quality = 1; let isLowQuality = false; let isNormalQuality = true; let isHighQuality = false; const QUALITY_LOW = 1; const QUALITY_NORMAL = 2; const QUALITY_HIGH = 3; const SKY_LIGHT_NONE = 0; const SKY_LIGHT_DIM = 1; const SKY_LIGHT_NORMAL = 2; const COLOR = { Red: '#ff0043', Green: '#14fc56', Blue: '#1e7fff', Purple: '#e60aff', Gold: '#ffbf36', White: '#ffffff' }; // Special invisible color (not rendered, and therefore not in COLOR map) const INVISIBLE = '_INVISIBLE_'; const PI_2 = Math.PI * 2; const PI_HALF = Math.PI * 0.5; // Stage.disableHighDPI = true; const trailsStage = new Stage('trails-canvas'); const mainStage = new Stage('main-canvas'); const stages = [ trailsStage, mainStage ]; // Fullscreen helpers, using Fscreen for prefixes. function fullscreenEnabled() { return fscreen.fullscreenEnabled; } // Note that fullscreen state is synced to store, and the store should be the source // of truth for whether the app is in fullscreen mode or not. function isFullscreen() { return !!fscreen.fullscreenElement; } // Attempt to toggle fullscreen mode. function toggleFullscreen() { if (fullscreenEnabled()) { if (isFullscreen()) { fscreen.exitFullscreen(); } else { fscreen.requestFullscreen(document.documentElement); } } } // Sync fullscreen changes with store. An event listener is necessary because the user can // toggle fullscreen mode directly through the browser, and we want to react to that. // The language of this project was translated into Chinese by Nianbroken fscreen.addEventListener('fullscreenchange', () => { store.setState({ fullscreen: isFullscreen() }); }); // Simple state container; the source of truth. const store = { _listeners: new Set(), _dispatch(prevState) { this._listeners.forEach(listener => listener(this.state, prevState)) }, state: { // will be unpaused in init() paused: true, soundEnabled: true, menuOpen: false, openHelpTopic: null, fullscreen: isFullscreen(), // Note that config values used for s must be strings, unless manually converting values to strings // at render time, and parsing on change. config: { quality: String(IS_HIGH_END_DEVICE ? QUALITY_HIGH : QUALITY_NORMAL), // will be mirrored to a global variable named `quality` in `configDidUpdate`, for perf. shell: 'Random', size: IS_DESKTOP ? '3' // Desktop default : IS_HEADER ? '1.2' // Profile header default (doesn't need to be an int) : '2', // Mobile default autoLaunch: true, finale: true, skyLighting: SKY_LIGHT_NORMAL + '', hideControls: IS_HEADER, longExposure: false, scaleFactor: getDefaultScaleFactor() } }, setState(nextState) { const prevState = this.state; this.state = Object.assign({}, this.state, nextState); this._dispatch(prevState); this.persist(); }, subscribe(listener) { this._listeners.add(listener); return () => this._listeners.remove(listener); }, // Load / persist select state to localStorage // Mutates state because `store.load()` should only be called once immediately after store is created, before any subscriptions. load() { const serializedData = localStorage.getItem('cm_fireworks_data'); if (serializedData) { const { schemaVersion, data } = JSON.parse(serializedData); const config = this.state.config; switch(schemaVersion) { case '1.1': config.quality = data.quality; config.size = data.size; config.skyLighting = data.skyLighting; break; case '1.2': config.quality = data.quality; config.size = data.size; config.skyLighting = data.skyLighting; config.scaleFactor = data.scaleFactor; break; default: throw new Error('version switch should be exhaustive'); } console.log(`Loaded config (schema version ${schemaVersion})`); } // Deprecated data format. Checked with care (it's not namespaced). else if (localStorage.getItem('schemaVersion') === '1') { let size; // Attempt to parse data, ignoring if there is an error. try { const sizeRaw = localStorage.getItem('configSize'); size = typeof sizeRaw === 'string' && JSON.parse(sizeRaw); } catch(e) { console.log('Recovered from error parsing saved config:'); console.error(e); return; } // Only restore validated values const sizeInt = parseInt(size, 10); if (sizeInt >= 0 && sizeInt !state.paused && !state.menuOpen; // Whether user has enabled sound. const soundEnabledSelector = (state=store.state) => state.soundEnabled; // Whether any sounds are allowed, taking into account multiple factors. const canPlaySoundSelector = (state=store.state) => isRunning(state) && soundEnabledSelector(state); // Convert quality to number. const qualitySelector = () => +store.state.config.quality; const shellNameSelector = () => store.state.config.shell; // Convert shell size to number. const shellSizeSelector = () => +store.state.config.size; const finaleSelector = () => store.state.config.finale; const skyLightingSelector = () => +store.state.config.skyLighting; const scaleFactorSelector = () => store.state.config.scaleFactor; // Help Content const helpContent = { shellType: { header: 'ÁÉüËä±Á±ªÂûã', body: '‰Ω†Ë¶ÅÊîæÁöÑÁÉüËä±ÁöÑÁ±ªÂûãÔºåÈÄâÊã©‚ÄúÈöèÊú∫ÔºàRandomÔºâ‚ÄùÂèØ‰ª•Ëé∑ÂæóÈùûÂ∏∏Â•ΩÁöÑ‰ΩìÈ™åÔºÅ' }, shellSize: { header: 'ÁÉüËä±Â§ßÂ∞è', body: 'ÁÉüËä±Ë∂äÂ§ßÁªΩÊîæËåÉÂõ¥Â∞±Ë∂äÂ§ßÔºå‰ΩÜÊòØÁÉüËä±Ë∂äÂ§ßÔºåËÆæÂ§áÊâÄÈúÄÁöÑÊÄßËÉΩ‰πü‰ºöÂ¢ûÂ§öÔºåÂ§ßÁöÑÁÉüËä±ÂèØËÉΩÂØºËá¥‰Ω†ÁöÑËÆæÂ§áÂç°È°ø„ÄÇ' }, quality: { header: 'ÁîªË¥®', body: 'Â¶ÇÊûúÂä®ÁîªËøêË°å‰∏çÊµÅÁïÖÔºå‰Ω†ÂèØ‰ª•ËØïËØïÈôç‰ΩéÁîªË¥®„ÄÇÁîªË¥®Ë∂äÈ´òÔºåÁÉüËä±ÁªΩÊîæÂêéÁöÑÁÅ´Ëä±Êï∞ÈáèÂ∞±Ë∂äÂ§öÔºå‰ΩÜÈ´òÁîªË¥®ÂèØËÉΩÂØºËá¥‰Ω†ÁöÑËÆæÂ§áÂç°È°ø„ÄÇ' }, skyLighting: { header: 'ÁÖß‰∫ÆÂ§©Á©∫', body: 'ÁÉüËä±ÁàÜÁÇ∏Êó∂ÔºåËÉåÊôØ‰ºöË¢´ÁÖß‰∫Æ„ÄÇÂ¶ÇÊûú‰Ω†ÁöÑÂ±èÂπïÁúãËµ∑Êù•Â§™‰∫Æ‰∫ÜÔºåÂèØ‰ª•ÊääÂÆÉÊîπÊàê‚ÄúÊöó‚ÄùÊàñËÄÖ‚Äú‰∏ç‚Äù„ÄÇ' }, scaleFactor: { header: 'Áº©Êîæ', body: '‰Ωø‰Ω†‰∏éÁÉüËä±Á¶ªÂæóÊõ¥ËøëÊàñÊõ¥Ëøú„ÄÇÂØπ‰∫éËæÉÂ§ßÁöÑÁÉüËä±Ôºå‰Ω†ÂèØ‰ª•ÈÄâÊã©Êõ¥Â∞èÁöÑÁº©ÊîæÂÄºÔºåÂ∞§ÂÖ∂ÊòØÂú®ÊâãÊú∫ÊàñÂπ≥ÊùøÁîµËÑë‰∏ä„ÄÇ' }, autoLaunch: { header: 'Ëá™Âä®ÊîæÁÉüËä±', body: 'ÂºÄÂêØÂêé‰Ω†Â∞±ÂèØ‰ª•ÂùêÂú®‰Ω†ÁöÑËÆæÂ§áÂ±èÂπïÂâçÈù¢Ê¨£ËµèÁÉüËä±‰∫ÜÔºå‰Ω†‰πüÂèØ‰ª•ÂÖ≥Èó≠ÂÆÉÔºå‰ΩÜÂÖ≥Èó≠Âêé‰Ω†Â∞±Âè™ËÉΩÈÄöËøáÁÇπÂáªÂ±èÂπïÁöÑÊñπÂºèÊù•ÊîæÁÉüËä±„ÄÇ' }, finaleMode: { header: 'ÂêåÊó∂ÊîæÊõ¥Â§öÁöÑÁÉüËä±', body: 'ÂèØ‰ª•Âú®Âêå‰∏ÄÊó∂Èó¥Ëá™Âä®ÊîæÂá∫Êõ¥Â§öÁöÑÁÉüËä±Ôºà‰ΩÜÈúÄË¶ÅÂºÄÂêØÂÖàÂºÄÂêØ‚ÄúËá™Âä®ÊîæÁÉüËä±‚ÄùÔºâ„ÄÇ' }, hideControls: { header: 'ÈöêËóèÊéßÂà∂ÊåâÈíÆ', body: 'ÈöêËóèÂ±èÂπïÈ°∂ÈÉ®ÁöÑÊåâÈíÆ„ÄÇÂ¶ÇÊûú‰Ω†Ë¶ÅÊà™ÂõæÔºåÊàñËÄÖÈúÄË¶Å‰∏Ä‰∏™Êó†ÁºùÁöÑ‰ΩìÈ™åÔºå‰Ω†Â∞±ÂèØ‰ª•Â∞ÜÊåâÈíÆÈöêËóèÔºåÈöêËóèÊåâÈíÆÂêé‰Ω†‰ªçÁÑ∂ÂèØ‰ª•Âú®Âè≥‰∏äËßíÊâìÂºÄËÆæÁΩÆ„ÄÇ' }, fullscreen: { header: 'ÂÖ®Â±è', body: 'ÂàáÊç¢Ëá≥ÂÖ®Â±èÊ®°Âºè' }, longExposure: { header: '‰øùÁïôÁÉüËä±ÁöÑÁÅ´Ëä±', body: 'ÂèØ‰ª•‰øùÁïôÁÉüËä±Áïô‰∏ãÁöÑÁÅ´Ëä±' } }; const nodeKeyToHelpKey = { shellTypeLabel: 'shellType', shellSizeLabel: 'shellSize', qualityLabel: 'quality', skyLightingLabel: 'skyLighting', scaleFactorLabel: 'scaleFactor', autoLaunchLabel: 'autoLaunch', finaleModeLabel: 'finaleMode', hideControlsLabel: 'hideControls', fullscreenLabel: 'fullscreen', longExposureLabel: 'longExposure' }; // Render app UI / keep in sync with state const appNodes = { stageContainer: '.stage-container', canvasContainer: '.canvas-container', controls: '.controls', menu: '.menu', menuInnerWrap: '.menu__inner-wrap', pauseBtn: '.pause-btn', pauseBtnSVG: '.pause-btn use', soundBtn: '.sound-btn', soundBtnSVG: '.sound-btn use', shellType: '.shell-type', shellTypeLabel: '.shell-type-label', shellSize: '.shell-size', shellSizeLabel: '.shell-size-label', quality: '.quality-ui', qualityLabel: '.quality-ui-label', skyLighting: '.sky-lighting', skyLightingLabel: '.sky-lighting-label', scaleFactor: '.scaleFactor', scaleFactorLabel: '.scaleFactor-label', autoLaunch: '.auto-launch', autoLaunchLabel: '.auto-launch-label', finaleModeFormOption: '.form-option--finale-mode', finaleMode: '.finale-mode', finaleModeLabel: '.finale-mode-label', hideControls: '.hide-controls', hideControlsLabel: '.hide-controls-label', fullscreenFormOption: '.form-option--fullscreen', fullscreen: '.fullscreen', fullscreenLabel: '.fullscreen-label', longExposure: '.long-exposure', longExposureLabel: '.long-exposure-label', // Help UI helpModal: '.help-modal', helpModalOverlay: '.help-modal__overlay', helpModalHeader: '.help-modal__header', helpModalBody: '.help-modal__body', helpModalCloseBtn: '.help-modal__close-btn' }; // Convert appNodes selectors to dom nodes Object.keys(appNodes).forEach(key => { appNodes[key] = document.querySelector(appNodes[key]); }); // Remove fullscreen control if not supported. if (!fullscreenEnabled()) { appNodes.fullscreenFormOption.classList.add('remove'); } // First render is called in init() function renderApp(state) { const pauseBtnIcon = `#icon-${state.paused ? 'play' : 'pause'}`; const soundBtnIcon = `#icon-sound-${soundEnabledSelector() ? 'on' : 'off'}`; appNodes.pauseBtnSVG.setAttribute('href', pauseBtnIcon); appNodes.pauseBtnSVG.setAttribute('xlink:href', pauseBtnIcon); appNodes.soundBtnSVG.setAttribute('href', soundBtnIcon); appNodes.soundBtnSVG.setAttribute('xlink:href', soundBtnIcon); appNodes.controls.classList.toggle('hide', state.menuOpen || state.config.hideControls); appNodes.canvasContainer.classList.toggle('blur', state.menuOpen); appNodes.menu.classList.toggle('hide', !state.menuOpen); appNodes.finaleModeFormOption.style.opacity = state.config.autoLaunch ? 1 : 0.32; appNodes.quality.value = state.config.quality; appNodes.shellType.value = state.config.shell; appNodes.shellSize.value = state.config.size; appNodes.autoLaunch.checked = state.config.autoLaunch; appNodes.finaleMode.checked = state.config.finale; appNodes.skyLighting.value = state.config.skyLighting; appNodes.hideControls.checked = state.config.hideControls; appNodes.fullscreen.checked = state.fullscreen; appNodes.longExposure.checked = state.config.longExposure; appNodes.scaleFactor.value = state.config.scaleFactor.toFixed(2); appNodes.menuInnerWrap.style.opacity = state.openHelpTopic ? 0.12 : 1; appNodes.helpModal.classList.toggle('active', !!state.openHelpTopic); if (state.openHelpTopic) { const { header, body } = helpContent[state.openHelpTopic]; appNodes.helpModalHeader.textContent = header; appNodes.helpModalBody.textContent = body; } } store.subscribe(renderApp); // Perform side effects on state changes function handleStateChange(state, prevState) { const canPlaySound = canPlaySoundSelector(state); const canPlaySoundPrev = canPlaySoundSelector(prevState); if (canPlaySound !== canPlaySoundPrev) { if (canPlaySound) { soundManager.resumeAll(); } else { soundManager.pauseAll(); } } } store.subscribe(handleStateChange); function getConfigFromDOM() { return { quality: appNodes.quality.value, shell: appNodes.shellType.value, size: appNodes.shellSize.value, autoLaunch: appNodes.autoLaunch.checked, finale: appNodes.finaleMode.checked, skyLighting: appNodes.skyLighting.value, longExposure: appNodes.longExposure.checked, hideControls: appNodes.hideControls.checked, // Store value as number. scaleFactor: parseFloat(appNodes.scaleFactor.value) }; }; const updateConfigNoEvent = () => updateConfig(); appNodes.quality.addEventListener('input', updateConfigNoEvent); appNodes.shellType.addEventListener('input', updateConfigNoEvent); appNodes.shellSize.addEventListener('input', updateConfigNoEvent); appNodes.autoLaunch.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.finaleMode.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.skyLighting.addEventListener('input', updateConfigNoEvent); appNodes.longExposure.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.hideControls.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.fullscreen.addEventListener('click', () => setTimeout(toggleFullscreen, 0)); // Changing scaleFactor requires triggering resize handling code as well. appNodes.scaleFactor.addEventListener('input', () => { updateConfig(); handleResize(); }); Object.keys(nodeKeyToHelpKey).forEach(nodeKey => { const helpKey = nodeKeyToHelpKey[nodeKey]; appNodes[nodeKey].addEventListener('click', () => { store.setState({ openHelpTopic: helpKey }); }); }); appNodes.helpModalCloseBtn.addEventListener('click', () => { store.setState({ openHelpTopic: null }); }); appNodes.helpModalOverlay.addEventListener('click', () => { store.setState({ openHelpTopic: null }); }); // Constant derivations const COLOR_NAMES = Object.keys(COLOR); const COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]); // Invisible stars need an indentifier, even through they won't be rendered - physics still apply. const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE]; // Map of color codes to their index in the array. Useful for quickly determining if a color has already been updated in a loop. const COLOR_CODE_INDEXES = COLOR_CODES_W_INVIS.reduce((obj, code, i) => { obj[code] = i; return obj; }, {}); // Tuples is a map keys by color codes (hex) with values of { r, g, b } tuples (still just objects). const COLOR_TUPLES = {}; COLOR_CODES.forEach(hex => { COLOR_TUPLES[hex] = { r: parseInt(hex.substr(1, 2), 16), g: parseInt(hex.substr(3, 2), 16), b: parseInt(hex.substr(5, 2), 16), }; }); // Get a random color. function randomColorSimple() { return COLOR_CODES[Math.random() * COLOR_CODES.length | 0]; } // Get a random color, with some customization options available. let lastColor; function randomColor(options) { const notSame = options && options.notSame; const notColor = options && options.notColor; const limitWhite = options && options.limitWhite; let color = randomColorSimple(); // limit the amount of white chosen randomly if (limitWhite && color === COLOR.White && Math.random() < 0.6) { color = randomColorSimple(); } if (notSame) { while (color === lastColor) { color = randomColorSimple(); } } else if (notColor) { while (color === notColor) { color = randomColorSimple(); } } lastColor = color; return color; } function whiteOrGold() { return Math.random() < 0.5 ? COLOR.Gold : COLOR.White; } // Shell helpers function makePistilColor(shellColor) { return (shellColor === COLOR.White || shellColor === COLOR.Gold) ? randomColor({ notColor: shellColor }) : whiteOrGold(); } // Unique shell types const crysanthemumShell = (size=1) => { const glitter = Math.random() < 0.25; const singleColor = Math.random() < 0.72; const color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })]; const pistil = singleColor && Math.random() < 0.42; const pistilColor = pistil && makePistilColor(color); const secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({ notColor: color, limitWhite: true }) : null; const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42; let starDensity = glitter ? 1.1 : 1.25; if (isLowQuality) starDensity *= 0.8; if (isHighQuality) starDensity = 1.2; return { shellSize: size, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starDensity, color, secondColor, glitter: glitter ? 'light' : '', glitterColor: whiteOrGold(), pistil, pistilColor, streamers }; }; const ghostShell = (size=1) => { // Extend crysanthemum shell const shell = crysanthemumShell(size); // Ghost effect can be fast, so extend star life shell.starLife *= 1.5; // Ensure we always have a single color other than white let ghostColor = randomColor({ notColor: COLOR.White }); // Always use streamers, and sometimes a pistil shell.streamers = true; const pistil = Math.random() < 0.42; const pistilColor = pistil && makePistilColor(ghostColor); // Ghost effect - transition from invisible to chosen color shell.color = INVISIBLE; shell.secondColor = ghostColor; // We don't want glitter to be spewed by invisible stars, and we don't currently // have a way to transition glitter state. So we'll disable it. shell.glitter = ''; return shell; }; const strobeShell = (size=1) => { const color = randomColor({ limitWhite: true }); return { shellSize: size, spreadSize: 280 + size * 92, starLife: 1100 + size * 200, starLifeVariation: 0.40, starDensity: 1.1, color, glitter: 'light', glitterColor: COLOR.White, strobe: true, strobeColor: Math.random() < 0.5 ? COLOR.White : null, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color) }; }; const palmShell = (size=1) => { const color = randomColor(); const thick = Math.random() < 0.5; return { shellSize: size, color, spreadSize: 250 + size * 75, starDensity: thick ? 0.15 : 0.4, starLife: 1800 + size * 200, glitter: thick ? 'thick' : 'heavy' }; }; const ringShell = (size=1) => { const color = randomColor(); const pistil = Math.random() < 0.75; return { shellSize: size, ring: true, color, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starCount: 2.2 * PI_2 * (size+1), pistil, pistilColor: makePistilColor(color), glitter: !pistil ? 'light' : '', glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White, streamers: Math.random() < 0.3 }; // return Object.assign({}, defaultShell, config); }; const crossetteShell = (size=1) => { const color = randomColor({ limitWhite: true }); return { shellSize: size, spreadSize: 300 + size * 100, starLife: 750 + size * 160, starLifeVariation: 0.4, starDensity: 0.85, color, crossette: true, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color) }; }; const floralShell = (size=1) => ({ shellSize: size, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, color: Math.random() < 0.65 ? 'random' : (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })]), floral: true }); const fallingLeavesShell = (size=1) => ({ shellSize: size, color: INVISIBLE, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, glitter: 'medium', glitterColor: COLOR.Gold, fallingLeaves: true }); const willowShell = (size=1) => ({ shellSize: size, spreadSize: 300 + size * 100, starDensity: 0.6, starLife: 3000 + size * 300, glitter: 'willow', glitterColor: COLOR.Gold, color: INVISIBLE }); const crackleShell = (size=1) => { // favor gold const color = Math.random() < 0.75 ? COLOR.Gold : randomColor(); return { shellSize: size, spreadSize: 380 + size * 75, starDensity: isLowQuality ? 0.65 : 1, starLife: 600 + size * 100, starLifeVariation: 0.32, glitter: 'light', glitterColor: COLOR.Gold, color, crackle: true, pistil: Math.random() < 0.65, pistilColor: makePistilColor(color) }; }; const horsetailShell = (size=1) => { const color = randomColor(); return { shellSize: size, horsetail: true, color, spreadSize: 250 + size * 38, starDensity: 0.9, starLife: 2500 + size * 300, glitter: 'medium', glitterColor: Math.random() < 0.5 ? whiteOrGold() : color, // Add strobe effect to white horsetails, to make them more interesting strobe: color === COLOR.White }; }; function randomShellName() { return Math.random() < 0.5 ? 'Crysanthemum' : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0 ]; } function randomShell(size) { // Special selection for codepen header. if (IS_HEADER) return randomFastShell()(size); // Normal operation return shellTypes[randomShellName()](size); } function shellFromConfig(size) { return shellTypes[shellNameSelector()](size); } // Get a random shell, not including processing intensive varients // Note this is only random when \"Random\" shell is selected in config. // Also, this does not create the shell, only returns the factory function. const fastShellBlacklist = ['Falling Leaves', 'Floral', 'Willow']; function randomFastShell() { const isRandom = shellNameSelector() === 'Random'; let shellName = isRandom ? randomShellName() : shellNameSelector(); if (isRandom) { while (fastShellBlacklist.includes(shellName)) { shellName = randomShellName(); } } return shellTypes[shellName]; } const shellTypes = { 'Random': randomShell, 'Crackle': crackleShell, 'Crossette': crossetteShell, 'Crysanthemum': crysanthemumShell, 'Falling Leaves': fallingLeavesShell, 'Floral': floralShell, 'Ghost': ghostShell, 'Horse Tail': horsetailShell, 'Palm': palmShell, 'Ring': ringShell, 'Strobe': strobeShell, 'Willow': willowShell }; const shellNames = Object.keys(shellTypes); function init() { // Remove loading state document.querySelector('.loading-init').remove(); appNodes.stageContainer.classList.remove('remove'); // Populate dropdowns function setOptionsForSelect(node, options) { node.innerHTML = options.reduce((acc, opt) => acc += `${opt.label}`, ''); } // shell type let options = ''; shellNames.forEach(opt => options += `${opt}`); appNodes.shellType.innerHTML = options; // shell size options = ''; ['3\"', '4\"', '6\"', '8\"', '12\"', '16\"'].forEach((opt, i) => options += `${opt}`); appNodes.shellSize.innerHTML = options; setOptionsForSelect(appNodes.quality, [ { label: '‰Ωé', value: QUALITY_LOW }, { label: 'Ê≠£Â∏∏', value: QUALITY_NORMAL }, { label: 'È´ò', value: QUALITY_HIGH } ]); setOptionsForSelect(appNodes.skyLighting, [ { label: '‰∏ç', value: SKY_LIGHT_NONE }, { label: 'Êöó', value: SKY_LIGHT_DIM }, { label: 'Ê≠£Â∏∏', value: SKY_LIGHT_NORMAL } ]); // 0.9 is mobile default setOptionsForSelect( appNodes.scaleFactor, [0.5, 0.62, 0.75, 0.9, 1.0, 1.5, 2.0] .map(value => ({ value: value.toFixed(2), label: `${value*100}%` })) ); // Begin simulation togglePause(false); // initial render renderApp(store.state); // Apply initial config configDidUpdate(); } function fitShellPositionInBoundsH(position) { const edge = 0.18; return (1 - edge*2) * position + edge; } function fitShellPositionInBoundsV(position) { return position * 0.75; } function getRandomShellPositionH() { return fitShellPositionInBoundsH(Math.random()); } function getRandomShellPositionV() { return fitShellPositionInBoundsV(Math.random()); } function getRandomShellSize() { const baseSize = shellSizeSelector(); const maxVariance = Math.min(2.5, baseSize); const variance = Math.random() * maxVariance; const size = baseSize - variance; const height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance); const centerOffset = Math.random() * (1 - height * 0.65) * 0.5; const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset; return { size, x: fitShellPositionInBoundsH(x), height: fitShellPositionInBoundsV(height) }; } // Launches a shell from a user pointer event, based on state.config function launchShellFromConfig(event) { const shell = new Shell(shellFromConfig(shellSizeSelector())); const w = mainStage.width; const h = mainStage.height; shell.launch( event ? event.x / w : getRandomShellPositionH(), event ? 1 - event.y / h : getRandomShellPositionV() ); } // Sequences // ----------- function seqRandomShell() { const size = getRandomShellSize(); const shell = new Shell(shellFromConfig(size.size)); shell.launch(size.x, size.height); let extraDelay = shell.starLife; if (shell.fallingLeaves) { extraDelay = 4600; } return 900 + Math.random() * 600 + extraDelay; } function seqRandomFastShell() { const shellType = randomFastShell(); const size = getRandomShellSize(); const shell = new Shell(shellType(size.size)); shell.launch(size.x, size.height); let extraDelay = shell.starLife; return 900 + Math.random() * 600 + extraDelay; } function seqTwoRandom() { const size1 = getRandomShellSize(); const size2 = getRandomShellSize(); const shell1 = new Shell(shellFromConfig(size1.size)); const shell2 = new Shell(shellFromConfig(size2.size)); const leftOffset = Math.random() * 0.2 - 0.1; const rightOffset = Math.random() * 0.2 - 0.1; shell1.launch(0.3 + leftOffset, size1.height); setTimeout(() => { shell2.launch(0.7 + rightOffset, size2.height); }, 100); let extraDelay = Math.max(shell1.starLife, shell2.starLife); if (shell1.fallingLeaves || shell2.fallingLeaves) { extraDelay = 4600; } return 900 + Math.random() * 600 + extraDelay; } function seqTriple() { const shellType = randomFastShell(); const baseSize = shellSizeSelector(); const smallSize = Math.max(0, baseSize - 1.25); const offset = Math.random() * 0.08 - 0.04; const shell1 = new Shell(shellType(baseSize)); shell1.launch(0.5 + offset, 0.7); const leftDelay = 1000 + Math.random() * 400; const rightDelay = 1000 + Math.random() * 400; setTimeout(() => { const offset = Math.random() * 0.08 - 0.04; const shell2 = new Shell(shellType(smallSize)); shell2.launch(0.2 + offset, 0.1); }, leftDelay); setTimeout(() => { const offset = Math.random() * 0.08 - 0.04; const shell3 = new Shell(shellType(smallSize)); shell3.launch(0.8 + offset, 0.1); }, rightDelay); return 4000; } function seqPyramid() { const barrageCountHalf = IS_DESKTOP ? 7 : 4; const largeSize = shellSizeSelector(); const smallSize = Math.max(0, largeSize - 3); const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell; const randomSpecialShell = randomShell; function launchShell(x, useSpecial) { const isRandom = shellNameSelector() === 'Random'; let shellType = isRandom ? useSpecial ? randomSpecialShell : randomMainShell : shellTypes[shellNameSelector()]; const shell = new Shell(shellType(useSpecial ? largeSize : smallSize)); const height = x { launchShell(offset, false); }, delay); setTimeout(() => { launchShell(1 - offset, false); }, delay + delayOffset); } count++; delay += 200; } return 3400 + barrageCountHalf * 250; } function seqSmallBarrage() { seqSmallBarrage.lastCalled = Date.now(); const barrageCount = IS_DESKTOP ? 11 : 5; const specialIndex = IS_DESKTOP ? 3 : 1; const shellSize = Math.max(0, shellSizeSelector() - 2); const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell; const randomSpecialShell = randomFastShell(); // (cos(x*5œÄ+0.5œÄ)+1)/2 is a custom wave bounded by 0 and 1 used to set varying launch heights function launchShell(x, useSpecial) { const isRandom = shellNameSelector() === 'Random'; let shellType = isRandom ? useSpecial ? randomSpecialShell : randomMainShell : shellTypes[shellNameSelector()]; const shell = new Shell(shellType(shellSize)); const height = (Math.cos(x*5*Math.PI + PI_HALF) + 1) / 2; shell.launch(x, height * 0.75); } let count = 0; let delay = 0; while(count < barrageCount) { if (count === 0) { launchShell(0.5, false) count += 1; } else { const offset = (count + 1) / barrageCount / 2; const delayOffset = Math.random() * 30 + 30; const useSpecial = count === specialIndex; setTimeout(() => { launchShell(0.5 + offset, useSpecial); }, delay); setTimeout(() => { launchShell(0.5 - offset, useSpecial); }, delay + delayOffset); count += 2; } delay += 200; } return 3400 + barrageCount * 120; } seqSmallBarrage.cooldown = 15000; seqSmallBarrage.lastCalled = Date.now(); const sequences = [ seqRandomShell, seqTwoRandom, seqTriple, seqPyramid, seqSmallBarrage ]; let isFirstSeq = true; const finaleCount = 32; let currentFinaleCount = 0; function startSequence() { if (isFirstSeq) { isFirstSeq = false; if (IS_HEADER) { return seqTwoRandom(); } else { const shell = new Shell(crysanthemumShell(shellSizeSelector())); shell.launch(0.5, 0.5); return 2400; } } if (finaleSelector()) { seqRandomFastShell(); if (currentFinaleCount < finaleCount) { currentFinaleCount++; return 170; } else { currentFinaleCount = 0; return 6000; } } const rand = Math.random(); if (rand < 0.08 && Date.now() - seqSmallBarrage.lastCalled > seqSmallBarrage.cooldown) { return seqSmallBarrage(); } if (rand < 0.1) { return seqPyramid(); } if (rand < 0.6 && !IS_HEADER) { return seqRandomShell(); } else if (rand < 0.8) { return seqTwoRandom(); } else if (rand < 1) { return seqTriple(); } } let activePointerCount = 0; let isUpdatingSpeed = false; function handlePointerStart(event) { activePointerCount++; const btnSize = 50; if (event.y < btnSize) { if (event.x < btnSize) { togglePause(); return; } if (event.x > mainStage.width/2 - btnSize/2 && event.x < mainStage.width/2 + btnSize/2) { toggleSound(); return; } if (event.x > mainStage.width - btnSize) { toggleMenu(); return; } } if (!isRunning()) return; if (updateSpeedFromEvent(event)) { isUpdatingSpeed = true; } else if (event.onCanvas) { launchShellFromConfig(event); } } function handlePointerEnd(event) { activePointerCount--; isUpdatingSpeed = false; } function handlePointerMove(event) { if (!isRunning()) return; if (isUpdatingSpeed) { updateSpeedFromEvent(event); } } function handleKeydown(event) { // P if (event.keyCode === 80) { togglePause(); } // O else if (event.keyCode === 79) { toggleMenu(); } // Esc else if (event.keyCode === 27) { toggleMenu(false); } } mainStage.addEventListener('pointerstart', handlePointerStart); mainStage.addEventListener('pointerend', handlePointerEnd); mainStage.addEventListener('pointermove', handlePointerMove); window.addEventListener('keydown', handleKeydown); // Account for window resize and custom scale changes. function handleResize() { const w = window.innerWidth; const h = window.innerHeight; // Try to adopt screen size, heeding maximum sizes specified const containerW = Math.min(w, MAX_WIDTH); // On small screens, use full device height const containerH = w stage.resize(containerW, containerH)); // Account for scale const scaleFactor = scaleFactorSelector(); stageW = containerW / scaleFactor; stageH = containerH / scaleFactor; } // Compute initial dimensions handleResize(); window.addEventListener('resize', handleResize); // Dynamic globals let currentFrame = 0; let speedBarOpacity = 0; let autoLaunchTime = 0; function updateSpeedFromEvent(event) { if (isUpdatingSpeed || event.y >= mainStage.height - 44) { // On phones it's hard to hit the edge pixels in order to set speed at 0 or 1, so some padding is provided to make that easier. const edge = 16; const newSpeed = (event.x - edge) / (mainStage.width - edge * 2); simSpeed = Math.min(Math.max(newSpeed, 0), 1); // show speed bar after an update speedBarOpacity = 1; // If we updated the speed, return true return true; } // Return false if the speed wasn't updated return false; } // Extracted function to keep `update()` optimized function updateGlobals(timeStep, lag) { currentFrame++; // Always try to fade out speed bar if (!isUpdatingSpeed) { speedBarOpacity -= lag / 30; // half a second if (speedBarOpacity < 0) { speedBarOpacity = 0; } } // auto launch shells if (store.state.config.autoLaunch) { autoLaunchTime -= timeStep; if (autoLaunchTime { // Stars const stars = Star.active[color]; for (let i=stars.length-1; i>=0; i=i-1) { const star = stars[i]; // Only update each star once per frame. Since color can change, it's possible a star could update twice without this, leading to a \"jump\". if (star.updateFrame === currentFrame) { continue; } star.updateFrame = currentFrame; star.life -= timeStep; if (star.life { const tuple = COLOR_TUPLES[color]; const count = Star.active[color].length; totalStarCount += count; targetSkyColor.r += tuple.r * count; targetSkyColor.g += tuple.g * count; targetSkyColor.b += tuple.b * count; }); // Clamp intensity at 1.0, and map to a custom non-linear curve. This allows few stars to perceivably light up the sky, while more stars continue to increase the brightness but at a lesser rate. This is more inline with humans' non-linear brightness perception. const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3); // Figure out which color component has the highest value, so we can scale them without affecting the ratios. // Prevent 0 from being used, so we don't divide by zero in the next step. const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b); // Scale all color components to a max of `maxSkySaturation`, and apply intensity. targetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity; targetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity; targetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity; // Animate changes to color to smooth out transitions. const colorChange = 10; currentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed; currentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed; currentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed; appNodes.canvasContainer.style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`; } mainStage.addEventListener('ticker', update); // Helper used to semi-randomly spread particles over an arc // Values are flexible - `start` and `arcLength` can be negative, and `randomness` is simply a multiplier for random addition. function createParticleArc(start, arcLength, count, randomness, particleFactory) { const angleDelta = arcLength / count; // Sometimes there is an extra particle at the end, too close to the start. Subtracting half the angleDelta ensures that is skipped. // Would be nice to fix this a better way. const end = start + arcLength - (angleDelta * 0.5); if (end > start) { // Optimization: `angle=angle+angleDelta` vs. angle+=angleDelta // V8 deoptimises with let compound assignment for (let angle=start; angleend; angle=angle+angleDelta) { particleFactory(angle + Math.random() * angleDelta * randomness); } } } /** * Helper used to create a spherical burst of particles. * * @param {Number} count The desired number of stars/particles. This value is a suggestion, and the * created burst may have more particles. The current algorithm can't perfectly * distribute a specific number of points evenly on a sphere's surface. * @param {Function} particleFactory Called once per star/particle generated. Passed two arguments: * `angle`: The direction of the star/particle. * `speed`: A multipler for the particle speed, from 0.0 to 1.0. * @param {Number} startAngle=0 For segmented bursts, you can generate only a partial arc of particles. This * allows setting the starting arc angle (radians). * @param {Number} arcLength=TAU The length of the arc (radians). Defaults to a full circle. * * @return {void} Returns nothing; it's up to `particleFactory` to use the given data. */ function createBurst(count, particleFactory, startAngle=0, arcLength=PI_2) { // Assuming sphere with surface area of `count`, calculate various // properties of said sphere (unit is stars). // Radius const R = 0.5 * Math.sqrt(count/Math.PI); // Circumference const C = 2 * R * Math.PI; // Half Circumference const C_HALF = C / 2; // Make a series of rings, sizing them as if they were spaced evenly // along the curved surface of a sphere. for (let i=0; i this.burst(comet.x, comet.y); soundManager.playSound('lift'); } burst(x, y) { // Set burst speed so overall burst grows to set size. This specific formula was derived from testing, and is affected by simulated air drag. const speed = this.spreadSize / 96; let color, onDeath, sparkFreq, sparkSpeed, sparkLife; let sparkLifeVariation = 0.25; // Some death effects, like crackle, play a sound, but should only be played once. let playedDeathSound = false; if (this.crossette) onDeath = (star) => { if (!playedDeathSound) { soundManager.playSound('crackleSmall'); playedDeathSound = true; } crossetteEffect(star); } if (this.crackle) onDeath = (star) => { if (!playedDeathSound) { soundManager.playSound('crackle'); playedDeathSound = true; } crackleEffect(star); } if (this.floral) onDeath = floralEffect; if (this.fallingLeaves) onDeath = fallingLeavesEffect; if (this.glitter === 'light') { sparkFreq = 400; sparkSpeed = 0.3; sparkLife = 300; sparkLifeVariation = 2; } else if (this.glitter === 'medium') { sparkFreq = 200; sparkSpeed = 0.44; sparkLife = 700; sparkLifeVariation = 2; } else if (this.glitter === 'heavy') { sparkFreq = 80; sparkSpeed = 0.8; sparkLife = 1400; sparkLifeVariation = 2; } else if (this.glitter === 'thick') { sparkFreq = 16; sparkSpeed = isHighQuality ? 1.65 : 1.5; sparkLife = 1400; sparkLifeVariation = 3; } else if (this.glitter === 'streamer') { sparkFreq = 32; sparkSpeed = 1.05; sparkLife = 620; sparkLifeVariation = 2; } else if (this.glitter === 'willow') { sparkFreq = 120; sparkSpeed = 0.34; sparkLife = 1400; sparkLifeVariation = 3.8; } // Apply quality to spark count sparkFreq = sparkFreq / quality; // Star factory for primary burst, pistils, and streamers. let firstStar = true; const starFactory = (angle, speedMult) => { // For non-horsetail shells, compute an initial vertical speed to add to star burst. // The magic number comes from testing what looks best. The ideal is that all shell // bursts appear visually centered for the majority of the star life (excl. willows etc.) const standardInitialSpeed = this.spreadSize / 1800; const star = Star.add( x, y, color || randomColor(), angle, speedMult * speed, // add minor variation to star life this.starLife + Math.random() * this.starLife * this.starLifeVariation, this.horsetail ? this.comet && this.comet.speedX : 0, this.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed ); if (this.secondColor) { star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32); star.secondColor = this.secondColor; } if (this.strobe) { star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46); star.strobe = true; // How many milliseconds between switch of strobe state \"tick\". Note that the strobe pattern // is on:off:off, so this is the \"on\" duration, while the \"off\" duration is twice as long. star.strobeFreq = Math.random() * 20 + 40; if (this.strobeColor) { star.secondColor = this.strobeColor; } } star.onDeath = onDeath; if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; } }; if (typeof this.color === 'string') { if (this.color === 'random') { color = null; // falsey value creates random color in starFactory } else { color = this.color; } // Rings have positional randomness, but are rotated randomly if (this.ring) { const ringStartAngle = Math.random() * Math.PI; const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;; createParticleArc(0, PI_2, this.starCount, 0, angle => { // Create a ring, squashed horizontally const initSpeedX = Math.sin(angle) * speed * ringSquash; const initSpeedY = Math.cos(angle) * speed; // Rotate ring const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY); const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle; const star = Star.add( x, y, color, newAngle, // apply near cubic falloff to speed (places more particles towards outside) newSpeed,//speed, // add minor variation to star life this.starLife + Math.random() * this.starLife * this.starLifeVariation ); if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; } }); } // Normal burst else { createBurst(this.starCount, starFactory); } } else if (Array.isArray(this.color)) { if (Math.random() < 0.5) { const start = Math.random() * Math.PI; const start2 = start + Math.PI; const arc = Math.PI; color = this.color[0]; // Not creating a full arc automatically reduces star count. createBurst(this.starCount, starFactory, start, arc); color = this.color[1]; createBurst(this.starCount, starFactory, start2, arc); } else { color = this.color[0]; createBurst(this.starCount / 2, starFactory); color = this.color[1]; createBurst(this.starCount / 2, starFactory); } } else { throw new Error('Invalid shell color. Expected string or array of strings, but got: ' + this.color); } if (this.pistil) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.5, starLife: this.starLife * 0.6, starLifeVariation: this.starLifeVariation, starDensity: 1.4, color: this.pistilColor, glitter: 'light', glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White }); innerShell.burst(x, y); } if (this.streamers) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.9, starLife: this.starLife * 0.8, starLifeVariation: this.starLifeVariation, starCount: Math.floor(Math.max(6, this.spreadSize / 45)), color: COLOR.White, glitter: 'streamer' }); innerShell.burst(x, y); } // Queue burst flash render BurstFlash.add(x, y, this.spreadSize / 4); // Play sound, but only for \"original\" shell, the one that was launched. // We don't want multiple sounds from pistil or streamer \"sub-shells\". // This can be detected by the presence of a comet. if (this.comet) { // Scale explosion sound based on current shell size and selected (max) shell size. // Shooting selected shell size will always sound the same no matter the selected size, // but when smaller shells are auto-fired, they will sound smaller. It doesn't sound great // when a value too small is given though, so instead of basing it on proportions, we just // look at the difference in size and map it to a range known to sound good. // The language of this project was translated into Chinese by Nianbroken const maxDiff = 2; const sizeDifferenceFromMaxSize = Math.min(maxDiff, shellSizeSelector() - this.shellSize); const soundScale = (1 - sizeDifferenceFromMaxSize / maxDiff) * 0.3 + 0.7; soundManager.playSound('burst', soundScale); } } } const BurstFlash = { active: [], _pool: [], _new() { return {} }, add(x, y, radius) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.radius = radius; this.active.push(instance); return instance; }, returnInstance(instance) { this._pool.push(instance); } }; // Helper to generate objects for storing active particles. // Particles are stored in arrays keyed by color (code, not name) for improved rendering performance. function createParticleCollection() { const collection = {}; COLOR_CODES_W_INVIS.forEach(color => { collection[color] = []; }); return collection; } // Star properties (WIP) // ----------------------- // transitionTime - how close to end of life that star transition happens const Star = { // Visual properties drawWidth: 3, airDrag: 0.98, airDragHeavy: 0.992, // Star particles will be keyed by color active: createParticleCollection(), _pool: [], _new() { return {}; }, add(x, y, color, angle, speed, life, speedOffX, speedOffY) { const instance = this._pool.pop() || this._new(); instance.visible = true; instance.heavy = false; instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed + (speedOffX || 0); instance.speedY = Math.cos(angle) * speed + (speedOffY || 0); instance.life = life; instance.fullLife = life; instance.spinAngle = Math.random() * PI_2; instance.spinSpeed = 0.8; instance.spinRadius = 0; instance.sparkFreq = 0; // ms between spark emissions instance.sparkSpeed = 1; instance.sparkTimer = 0; instance.sparkColor = color; instance.sparkLife = 750; instance.sparkLifeVariation = 0.25; instance.strobe = false; this.active[color].push(instance); return instance; }, // Public method for cleaning up and returning an instance back to the pool. // Language translation of this project into Chinese by Nianbroken returnInstance(instance) { // Call onDeath handler if available (and pass it current star instance) instance.onDeath && instance.onDeath(instance); // Clean up instance.onDeath = null; instance.secondColor = null; instance.transitionTime = 0; instance.colorChanged = false; // Add back to the pool. this._pool.push(instance); } }; const Spark = { // Visual properties drawWidth: 0, // set in `configDidUpdate()` airDrag: 0.9, // Star particles will be keyed by color active: createParticleCollection(), _pool: [], _new() { return {}; }, add(x, y, color, angle, speed, life) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed; instance.speedY = Math.cos(angle) * speed; instance.life = life; this.active[color].push(instance); return instance; }, // Public method for cleaning up and returning an instance back to the pool. returnInstance(instance) { // Add back to the pool. this._pool.push(instance); } }; const soundManager = { baseURL: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/', ctx: new (window.AudioContext || window.webkitAudioContext), sources: { lift: { volume: 1, playbackRateMin: 0.85, playbackRateMax: 0.95, fileNames: [ 'lift1.mp3', 'lift2.mp3', 'lift3.mp3' ] }, burst: { volume: 1, playbackRateMin: 0.8, playbackRateMax: 0.9, fileNames: [ 'burst1.mp3', 'burst2.mp3' ] }, burstSmall: { volume: 0.25, playbackRateMin: 0.8, playbackRateMax: 1, fileNames: [ 'burst-sm-1.mp3', 'burst-sm-2.mp3' ] }, crackle: { volume: 0.2, playbackRateMin: 1, playbackRateMax: 1, fileNames: ['crackle1.mp3'] }, crackleSmall: { volume: 0.3, playbackRateMin: 1, playbackRateMax: 1, fileNames: ['crackle-sm-1.mp3'] } }, preload() { const allFilePromises = []; function checkStatus(response) { if (response.status >= 200 && response.status < 300) { return response; } const customError = new Error(response.statusText); customError.response = response; throw customError; } const types = Object.keys(this.sources); types.forEach(type => { const source = this.sources[type]; const { fileNames } = source; const filePromises = []; fileNames.forEach(fileName => { const fileURL = this.baseURL + fileName; // Promise will resolve with decoded audio buffer. const promise = fetch(fileURL) .then(checkStatus) .then(response => response.arrayBuffer()) .then(data => new Promise(resolve => { this.ctx.decodeAudioData(data, resolve); })); filePromises.push(promise); allFilePromises.push(promise); }); Promise.all(filePromises) .then(buffers => { source.buffers = buffers; }); }); return Promise.all(allFilePromises); }, pauseAll() { this.ctx.suspend(); }, resumeAll() { // Play a sound with no volume for iOS. This 'unlocks' the audio context when the user first enables sound. this.playSound('lift', 0); // Chrome mobile requires interaction before starting audio context. // The sound toggle button is triggered on 'touchstart', which doesn't seem to count as a full // interaction to Chrome. I guess it needs a click? At any rate if the first thing the user does // is enable audio, it doesn't work. Using a setTimeout allows the first interaction to be registered. // Perhaps a better solution is to track whether the user has interacted, and if not but they try enabling // sound, show a tooltip that they should tap again to enable sound. setTimeout(() => { this.ctx.resume(); }, 250); }, // Private property used to throttle small burst sounds. _lastSmallBurstTime: 0, /** * Play a sound of `type`. Will randomly pick a file associated with type, and play it at the specified volume * and play speed, with a bit of random variance in play speed. This is all based on `sources` config. * * @param {string} type - The type of sound to play. * @param {?number} scale=1 - Value between 0 and 1 (values outside range will be clamped). Scales less than one * descrease volume and increase playback speed. This is because large explosions are * louder, deeper, and reverberate longer than small explosions. * Note that a scale of 0 will mute the sound. */ playSound(type, scale=1) { // Ensure `scale` is within valid range. scale = MyMath.clamp(scale, 0, 1); // Disallow starting new sounds if sound is disabled, app is running in slow motion, or paused. // Slow motion check has some wiggle room in case user doesn't finish dragging the speed bar // *all* the way back. if (!canPlaySoundSelector() || simSpeed < 0.95) { return; } // Throttle small bursts, since floral/falling leaves shells have a lot of them. if (type === 'burstSmall') { const now = Date.now(); if (now - this._lastSmallBurstTime < 20) { return; } this._lastSmallBurstTime = now; } const source = this.sources[type]; if (!source) { throw new Error(`Sound of type \"${type}\" doesn't exist.`); } const initialVolume = source.volume; const initialPlaybackRate = MyMath.random( source.playbackRateMin, source.playbackRateMax ); // Volume descreases with scale. const scaledVolume = initialVolume * scale; // Playback rate increases with scale. For this, we map the scale of 0-1 to a scale of 2-1. // So at a scale of 1, sound plays normally, but as scale approaches 0 speed approaches double. const scaledPlaybackRate = initialPlaybackRate * (2 - scale); const gainNode = this.ctx.createGain(); gainNode.gain.value = scaledVolume; const buffer = MyMath.randomChoice(source.buffers); const bufferSource = this.ctx.createBufferSource(); bufferSource.playbackRate.value = scaledPlaybackRate; bufferSource.buffer = buffer; bufferSource.connect(gainNode); gainNode.connect(this.ctx.destination); bufferSource.start(0); } }; // Kick things off. function setLoadingStatus(status) { document.querySelector('.loading-init__status').textContent = status; } // CodePen profile header doesn't need audio, just initialize. if (IS_HEADER) { init(); } else { // Allow status to render, then preload assets and start app. setLoadingStatus('Ê≠£Âú®ÁÇπÁáÉÂØºÁÅ´Á∫ø'); setTimeout(() => { soundManager.preload() .then( init, reason => { // Codepen preview doesn't like to load the audio, so just init to fix the preview for now. init(); // setLoadingStatus('Error Loading Audio'); return Promise.reject(reason); } ); }, 0); }"},{"title":"","date":"2023-01-06T04:52:12.114Z","updated":"2021-03-26T09:16:16.000Z","comments":true,"path":"js/typed.js","permalink":"http://www.angforever.top/js/typed.js","excerpt":"","text":"/*! * * typed.js - A JavaScript Typing Animation Library * Author: Matt Boldt * Version: v2.0.12 * Url: https://github.com/mattboldt/typed.js * License(s): MIT * */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports[\"Typed\"] = factory(); else root[\"Typed\"] = factory(); })(this, function() { return /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } } var _initializerJs = __webpack_require__(1); var _htmlParserJs = __webpack_require__(3); /** * Welcome to Typed.js! * @param {string} elementId HTML element ID _OR_ HTML element * @param {object} options options object * @returns {object} a new Typed object */ var Typed = (function () { function Typed(elementId, options) { _classCallCheck(this, Typed); // Initialize it up _initializerJs.initializer.load(this, options, elementId); // All systems go! this.begin(); } /** * Toggle start() and stop() of the Typed instance * @public */ _createClass(Typed, [{ key: 'toggle', value: function toggle() { this.pause.status ? this.start() : this.stop(); } /** * Stop typing / backspacing and enable cursor blinking * @public */ }, { key: 'stop', value: function stop() { if (this.typingComplete) return; if (this.pause.status) return; this.toggleBlinking(true); this.pause.status = true; this.options.onStop(this.arrayPos, this); } /** * Start typing / backspacing after being stopped * @public */ }, { key: 'start', value: function start() { if (this.typingComplete) return; if (!this.pause.status) return; this.pause.status = false; if (this.pause.typewrite) { this.typewrite(this.pause.curString, this.pause.curStrPos); } else { this.backspace(this.pause.curString, this.pause.curStrPos); } this.options.onStart(this.arrayPos, this); } /** * Destroy this instance of Typed * @public */ }, { key: 'destroy', value: function destroy() { this.reset(false); this.options.onDestroy(this); } /** * Reset Typed and optionally restarts * @param {boolean} restart * @public */ }, { key: 'reset', value: function reset() { var restart = arguments.length curString.length) break; } // strip out the escape characters and append all the string in between var stringBeforeSkip = curString.substring(0, curStrPos); var stringSkipped = curString.substring(stringBeforeSkip.length + 1, curStrPos + numChars); var stringAfterSkip = curString.substring(curStrPos + numChars + 1); curString = stringBeforeSkip + stringSkipped + stringAfterSkip; numChars--; } // timeout for any pause after a character _this2.timeout = setTimeout(function () { // Accounts for blinking while paused _this2.toggleBlinking(false); // We're done with this sentence! if (curStrPos >= curString.length) { _this2.doneTyping(curString, curStrPos); } else { _this2.keepTyping(curString, curStrPos, numChars); } // end of character pause if (_this2.temporaryPause) { _this2.temporaryPause = false; _this2.options.onTypingResumed(_this2.arrayPos, _this2); } }, pauseTime); // humanized value for typing }, humanize); } /** * Continue to the next string & begin typing * @param {string} curString the current string in the strings array * @param {number} curStrPos the current position in the curString * @private */ }, { key: 'keepTyping', value: function keepTyping(curString, curStrPos, numChars) { // call before functions if applicable if (curStrPos === 0) { this.toggleBlinking(false); this.options.preStringTyped(this.arrayPos, this); } // start typing each new char into existing string // curString: arg, this.el.html: original text inside element curStrPos += numChars; var nextString = curString.substr(0, curStrPos); this.replaceText(nextString); // loop the function this.typewrite(curString, curStrPos); } /** * We're done typing the current string * @param {string} curString the current string in the strings array * @param {number} curStrPos the current position in the curString * @private */ }, { key: 'doneTyping', value: function doneTyping(curString, curStrPos) { var _this3 = this; // fires callback function this.options.onStringTyped(this.arrayPos, this); this.toggleBlinking(true); // is this the final string if (this.arrayPos === this.strings.length - 1) { // callback that occurs on the last typed string this.complete(); // quit if we wont loop back if (this.loop === false || this.curLoop === this.loopCount) { return; } } this.timeout = setTimeout(function () { _this3.backspace(curString, curStrPos); }, this.backDelay); } /** * Backspaces 1 character at a time * @param {string} curString the current string in the strings array * @param {number} curStrPos the current position in the curString * @private */ }, { key: 'backspace', value: function backspace(curString, curStrPos) { var _this4 = this; if (this.pause.status === true) { this.setPauseStatus(curString, curStrPos, false); return; } if (this.fadeOut) return this.initFadeOut(); this.toggleBlinking(false); var humanize = this.humanizer(this.backSpeed); this.timeout = setTimeout(function () { curStrPos = _htmlParserJs.htmlParser.backSpaceHtmlChars(curString, curStrPos, _this4); // replace text with base text + typed characters var curStringAtPosition = curString.substr(0, curStrPos); _this4.replaceText(curStringAtPosition); // if smartBack is enabled if (_this4.smartBackspace) { // the remaining part of the current string is equal of the same part of the new string var nextString = _this4.strings[_this4.arrayPos + 1]; if (nextString && curStringAtPosition === nextString.substr(0, curStrPos)) { _this4.stopNum = curStrPos; } else { _this4.stopNum = 0; } } // if the number (id of character in current string) is // less than the stop number, keep going if (curStrPos > _this4.stopNum) { // subtract characters one by one curStrPos--; // loop the function _this4.backspace(curString, curStrPos); } else if (curStrPos"},{"title":"Page","date":"2023-01-05T14:52:56.000Z","updated":"2023-01-05T09:29:56.726Z","comments":true,"path":"page/index.html","permalink":"http://www.angforever.top/page/index.html","excerpt":"","text":"This is a page test."},{"title":"","date":"2023-01-21T11:54:51.691Z","updated":"2022-02-03T08:41:41.875Z","comments":true,"path":"FIREWORKS/Evidence/README.html","permalink":"http://www.angforever.top/FIREWORKS/Evidence/README.html","excerpt":"","text":"ÁõÆÂâçÂ∑≤ÈÅìÊ≠âÊ≠§Êñá‰ª∂ÊòØ‰∏ìÈó®Áªô‚ÄùÂ∞è‰øä‚ÄúÁúãÁöÑÔºåÂ¶ÇÊûú‰Ω†‰∏çÊòØ‚ÄùÂ∞è‰øä‚ÄúÂèØ‰ª•Êó†ËßÜÊ≠§Êñá‰ª∂Áõ¥Êé•ÊääÊàëÁöÑÈ°πÁõÆ‰∏ãËΩΩ‰∏ãÊù•ÔºåÊîπ‰∏™ÂêçÂ≠óÂ∞±Êàê‰Ω†Ëá™Â∑±ÁöÑ‰∏úË•ø‰∫ÜÔºü Â¶ÇÊûúÊàëÊòØÊú∫Áøª ÈÇ£‰πà‰Ω†ÁõóÂèñÊàëÁöÑÊàêÊûú Êàë‰πü‰∏ç‰ºöËØ¥‰Ω†‰ªÄ‰πà ÂèØÊàëÊòØ‰∫∫Â∑•ÁøªËØë ‰Ω†ËøòÁõóÂèñ ‰Ω†ËøôÁßç‰∫∫ËÆ©ÊàëËßâÂæóÊÅ∂ÂøÉ ‰∫∫Â∑•ÁøªËØë‰Ω†ËøòÁøªËØëÁöÑË∑üÊàë‰∏ÄÊ®°‰∏ÄÊ†∑Ôºü ÁúüÊ≤°ÊÉ≥Âà∞Âú®Github‰πüËÉΩÈÅáÂà∞‰Ω†ËøôÁßç‰∫∫ ‰Ω†Â¶ÇÊûú‰∏ç‰ºöÊ±âÂåñÂèØ‰ª•‰∏çË¶ÅÊ±âÂåñ ‰∏ãËΩΩÊàëÁöÑÈ°πÁõÆÔºåÊää‚ÄúÁ¢éÂøµ‚ÄùÊîπÊàê‚ÄúÂ∞è‰øä‚ÄùÂ∞±ÊòØ‰Ω†ÁöÑ‰∏úË•ø‰∫ÜÔºü ‰ª•‰∏ã‰∏∫ËØÅÊçÆËØÅÊçÆ1Ôºö Âú®È°πÁõÆÁöÑ\\js\\script.jsÁöÑÁ¨¨312Ë°åÂºÄÂßãÔºå‰Ω†ÁøªËØëÁöÑË∑üÊàë‰∏ÄÊ®°‰∏ÄÊ†∑Ôºü ÊàëËøôÊòØ‰∫∫Â∑•ÁøªËØëÂëÄÔºåËÄå‰∏îÊàëÂæàÂ§öÁøªËØëÂÆåÂÖ®Ë∑üÂéüÊú¨ÊòØËã±ÊñáÂè•Â≠êÂØπ‰∏ç‰∏äÊÑèÊÄù ÊàëÁöÑÁøªËØëÊòØ‰∏∫‰∫ÜËÆ©Êõ¥Â§ö‰∫∫ËÉΩÁêÜËß£ÈÇ£‰∏™ÂäüËÉΩÁöÑ‰ΩúÁî® ‰æãÂ¶ÇÔºö Launches intense bursts of fireworks. May cause lag. Requires ‚ÄúAuto Fire‚Äù to be enabled. ÊàëÁøªËØë‰∏∫Ôºö ÂèØ‰ª•Âú®Âêå‰∏ÄÊó∂Èó¥Ëá™Âä®ÊîæÂá∫Êõ¥Â§öÁöÑÁÉüËä±Ôºà‰ΩÜÈúÄË¶ÅÂºÄÂêØÂÖàÂºÄÂêØ‚ÄúËá™Âä®ÊîæÁÉüËä±‚ÄùÔºâ„ÄÇ ÂÜç‰æãÂ¶ÇÔºö FINALE MODE ÊàëÁøªËØë‰∏∫ ÂêåÊó∂ÊîæÊõ¥Â§öÁöÑÁÉüËä± Â∞è‰øäÊÇ®ÂèØÁúüÂéâÂÆ≥ÂëÄÔºåÊÉ≥ÁöÑË∑üÊàë‰∏ÄÊ†∑ÔºÅ ËØÅÊçÆ2Ôºö Âú®È°πÁõÆÁöÑ\\js\\script.jsÁöÑÁ¨¨325Ë°åÊàëÊúâ‰∏Ä‰∏™ÊñáÂ≠óÁøªËØëÈîôËØØ ÂèØ‰ª•ÊääÂÆÉÊîπÊàê‚ÄúÊöó‚ÄùÊàñËÄÖ‚ÄúÊó†‚Äù„ÄÇ ËøôÈáåÂ∫îËØ•Êää‚ÄùÊó†‚ÄúÁøªËØë‰∏∫‚Äù‰∏ç‚Äú Âõ†‰∏∫Âú®\\js\\script.jsÁöÑÁ¨¨838Ë°åÊàëÁøªËØë‰∏∫‰∫Ü‚Äù‰∏ç‚Äú ‰Ω†ÈîôÈÉΩË∑üÊàëÈîôÁöÑ‰∏ÄÊ†∑ÔºüÈÇ£ÊÇ®ËøòÁúüÊòØÂéâÂÆ≥ÂëÄÔºÅ ËØÅÊçÆ3Ôºö Âú®È°πÁõÆÁöÑindex.htmlÁöÑÁ¨¨212Ë°å Â∏åÊúõ‰Ω†ÊâÄÊúâÁöÑ‰∏çÂºÄÂøÉ ÈÉΩÂèØ‰ª•Âú®Êú¨Á´ôÁöÑÂ£∞Â£∞ÁÉüËä±Â£∞‰∏≠ÁªìÊùü ÂéüÊñáÊ°à‰∏∫ Â∏åÊúõ‰Ω†ÊâÄÊúâÁöÑ‰∏çÂπ∏ ÈÉΩÂèØ‰ª•Âú®Êú¨Á´ôÁöÑÂ£∞Â£∞Èû≠ÁÇÆ‰∏≠ÁªìÊùü ËøôÊäÑÁöÑÂ§™ÊòéÊòæ‰∫ÜÂêßÔºüËøô‰∏™ÊñáÊ°àÂèØÊòØÊàëËá™Â∑±ÊÉ≥Âá∫Êù•ÁöÑÔºåÈöæÈÅì‰Ω†‰πüÊÉ≥ÁöÑË∑üÊàë‰∏ÄÊ†∑Ôºü"},{"title":"","date":"2023-01-21T11:54:52.097Z","updated":"2022-02-03T08:49:50.440Z","comments":true,"path":"FIREWORKS/js/MyMath.js","permalink":"http://www.angforever.top/FIREWORKS/js/MyMath.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ const MyMath = (function MyMathFactory(Math) { const MyMath = {}; // degree/radian conversion constants MyMath.toDeg = 180 / Math.PI; MyMath.toRad = Math.PI / 180; MyMath.halfPI = Math.PI / 2; MyMath.twoPI = Math.PI * 2; // Pythagorean Theorem distance calculation MyMath.dist = (width, height) => { return Math.sqrt(width * width + height * height); }; // Pythagorean Theorem point distance calculation // Same as above, but takes coordinates instead of dimensions. // The language of this project was translated into Chinese by Nianbroken MyMath.pointDist = (x1, y1, x2, y2) => { const distX = x2 - x1; const distY = y2 - y1; return Math.sqrt(distX * distX + distY * distY); }; // Returns the angle (in radians) of a 2D vector MyMath.angle = (width, height) => ( MyMath.halfPI + Math.atan2(height, width) ); // Returns the angle (in radians) between two points // Same as above, but takes coordinates instead of dimensions. MyMath.pointAngle = (x1, y1, x2, y2) => ( MyMath.halfPI + Math.atan2(y2 - y1, x2 - x1) ); // Splits a speed vector into x and y components (angle needs to be in radians) MyMath.splitVector = (speed, angle) => ({ x: Math.sin(angle) * speed, y: -Math.cos(angle) * speed }); // Generates a random number between min (inclusive) and max (exclusive) MyMath.random = (min, max) => Math.random() * (max - min) + min; // Generates a random integer between and possibly including min and max values MyMath.randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min; // Returns a random element from an array, or simply the set of provided arguments when called MyMath.randomChoice = function randomChoice(choices) { if (arguments.length === 1 && Array.isArray(choices)) { return choices[(Math.random() * choices.length) | 0]; } return arguments[(Math.random() * arguments.length) | 0]; }; // Clamps a number between min and max values MyMath.clamp = function clamp(num, min, max) { return Math.min(Math.max(num, min), max); }; return MyMath; })(Math);"},{"title":"","date":"2023-01-21T11:54:52.410Z","updated":"2022-02-03T08:52:06.384Z","comments":true,"path":"FIREWORKS/js/Stage.js","permalink":"http://www.angforever.top/FIREWORKS/js/Stage.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ const Ticker = (function TickerFactory(window) { 'use strict'; const Ticker = {}; // public // will call function reference repeatedly once registered, passing elapsed time and a lag multiplier as parameters Ticker.addListener = function addListener(callback) { if (typeof callback !== 'function') throw('Ticker.addListener() requires a function reference passed for a callback.'); listeners.push(callback); // start frame-loop lazily if (!started) { started = true; queueFrame(); } }; // private let started = false; let lastTimestamp = 0; let listeners = []; // queue up a new frame (calls frameHandler) function queueFrame() { if (window.requestAnimationFrame) { requestAnimationFrame(frameHandler); } else { webkitRequestAnimationFrame(frameHandler); } } function frameHandler(timestamp) { let frameTime = timestamp - lastTimestamp; lastTimestamp = timestamp; // make sure negative time isn't reported (first frame can be whacky) if (frameTime < 0) { frameTime = 17; } // - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal') else if (frameTime > 68) { frameTime = 68; } // fire custom listeners listeners.forEach(listener => listener.call(window, frameTime, frameTime / 16.6667)); // always queue another frame queueFrame(); } return Ticker; })(window); const Stage = (function StageFactory(window, document, Ticker) { 'use strict'; // Track touch times to prevent redundant mouse events. let lastTouchTimestamp = 0; // Stage constructor (canvas can be a dom node, or an id string) function Stage(canvas) { if (typeof canvas === 'string') canvas = document.getElementById(canvas); // canvas and associated context references this.canvas = canvas; this.ctx = canvas.getContext('2d'); // Prevent gestures on stages (scrolling, zooming, etc) this.canvas.style.touchAction = 'none'; // physics speed multiplier: allows slowing down or speeding up simulation (must be manually implemented in physics layer) this.speed = 1; // devicePixelRatio alias (should only be used for rendering, physics shouldn't care) // avoids rendering unnecessary pixels that browser might handle natively via CanvasRenderingContext2D.backingStorePixelRatio // Language translation of this project into Chinese by Nianbroken this.dpr = Stage.disableHighDPI ? 1 : ((window.devicePixelRatio || 1) / (this.ctx.backingStorePixelRatio || 1)); // canvas size in DIPs and natural pixels this.width = canvas.width; this.height = canvas.height; this.naturalWidth = this.width * this.dpr; this.naturalHeight = this.height * this.dpr; // size canvas to match natural size if (this.width !== this.naturalWidth) { this.canvas.width = this.naturalWidth; this.canvas.height = this.naturalHeight; this.canvas.style.width = this.width + 'px'; this.canvas.style.height = this.height + 'px'; } // To any known illigitimate users... const badDomains = ['bla'+'ckdiam'+'ondfirew'+'orks'+'.de']; const hostname = document.location.hostname; if (badDomains.some(d => hostname.includes(d))) { const delay = 60000 * 3; // 3 minutes setTimeout(() => { const html = ` `+` `+` bo`+`dy { bac`+`kgrou`+`nd-colo`+`r: #000;`+` padd`+`ing: `+`20px; text-`+`align:`+` center; col`+`or: `+`#ddd`+`; mi`+`n-he`+`ight`+`: 10`+`0vh;`+` dis`+`play`+`: fl`+`ex; `+`flex`+`-dir`+`ecti`+`on: `+`colu`+`mn; `+`just`+`ify-`+`cont`+`ent:`+` cen`+`ter;`+` ali`+`gn-i`+`tems`+`: ce`+`nter`+`; ov`+`erfl`+`ow: `+`visi`+`ble;`+` } `+` `+` h1 `+`{ fo`+`nt-s`+`ize:`+` 1.2`+`em;`+`} `+` `+`p { `+`marg`+`in-t`+`op: `+`1em;`+` max`+`-wid`+`th: `+`36em`+`; } `+` `+` a `+`{ co`+`lor:`+` #ff`+`f; tex`+`t-dec`+`orati`+`on: u`+`nderl`+`ine; }`+` `+` `+` `+``+`Hi! `+`Sorr`+`y to`+` int`+`erru`+`pt t`+`he f`+`irew`+`orks`+`. `+` `+`M`+`y na`+`me i`+`s Ca`+`leb.`+` Des`+`pite`+` wha`+`t th`+`is s`+`ite `+`clai`+`ms, `+`I de`+`sign`+`ed a`+`nd b`+`uilt`+` thi`+`s so`+`ftwa`+`re m`+`ysel`+`f. I`+`'ve `+`spen`+`t a `+`coup`+`le h`+`undr`+`ed h`+`ours`+` of `+`my o`+`wn t`+`ime, `+`over`+` tw`+`o ye`+`ars, `+`maki`+`ng i`+`t. `+` `+`T`+`he o`+`wner`+` of `+`this`+` sit`+`e cl`+`earl`+`y do`+`esn'`+`t re`+`spec`+`t my`+` wor`+`k, a`+`nd h`+`as l`+`abel`+`ed i`+`t as`+` the`+`ir o`+`wn. `+` `+` `+`If y`+`ou w`+`ere `+`enjo`+`ying`+` the`+` sho`+`w, p`+`leas`+`e ch`+`eck `+`out `+``+`my&n`+`bsp;`+`offi`+`cial`+`&nbs`+`p;ve`+`rsio`+`n&nb`+`sp;h`+`ere!`+` `+` `+` I`+`f you`+`'re th`+`e ow`+`ner, cont`+`act m`+`e`+`.`; document.body.innerHTML = html; }, delay); } Stage.stages.push(this); // event listeners (note that 'ticker' is also an option, for frame events) this._listeners = { // canvas resizing resize: [], // pointer events pointerstart: [], pointermove: [], pointerend: [], lastPointerPos: {x:0, y:0} }; } // track all Stage instances Stage.stages = []; // allow turning off high DPI support for perf reasons (enabled by default) // Note: MUST be set before Stage construction. // Each stage tracks its own DPI (initialized at construction time), so you can effectively allow some Stages to render high-res graphics but not others. // Language translation of this project into Chinese by Nianbroken Stage.disableHighDPI = false; // events Stage.prototype.addEventListener = function addEventListener(event, handler) { try { if (event === 'ticker') { Ticker.addListener(handler); }else{ this._listeners[event].push(handler); } } catch (e) { throw('Invalid Event') } }; Stage.prototype.dispatchEvent = function dispatchEvent(event, val) { const listeners = this._listeners[event]; if (listeners) { listeners.forEach(listener => listener.call(this, val)); }else{ throw('Invalid Event'); } }; // resize canvas Stage.prototype.resize = function resize(w, h) { this.width = w; this.height = h; this.naturalWidth = w * this.dpr; this.naturalHeight = h * this.dpr; this.canvas.width = this.naturalWidth; this.canvas.height = this.naturalHeight; this.canvas.style.width = w + 'px'; this.canvas.style.height = h + 'px'; this.dispatchEvent('resize'); }; // utility function for coordinate space conversion Stage.windowToCanvas = function windowToCanvas(canvas, x, y) { const bbox = canvas.getBoundingClientRect(); return { x: (x - bbox.left) * (canvas.width / bbox.width), y: (y - bbox.top) * (canvas.height / bbox.height) }; }; // handle interaction Stage.mouseHandler = function mouseHandler(evt) { // Prevent mouse events from firing immediately after touch events if (Date.now() - lastTouchTimestamp < 500) { return; } let type = 'start'; if (evt.type === 'mousemove') { type = 'move'; }else if (evt.type === 'mouseup') { type = 'end'; } Stage.stages.forEach(stage => { const pos = Stage.windowToCanvas(stage.canvas, evt.clientX, evt.clientY); stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr); }); }; Stage.touchHandler = function touchHandler(evt) { lastTouchTimestamp = Date.now(); // Set generic event type let type = 'start'; if (evt.type === 'touchmove') { type = 'move'; }else if (evt.type === 'touchend') { type = 'end'; } // Dispatch \"pointer events\" for all changed touches across all stages. Stage.stages.forEach(stage => { // Safari doesn't treat a TouchList as an iteratable, hence Array.from() for (let touch of Array.from(evt.changedTouches)) { let pos; if (type !== 'end') { pos = Stage.windowToCanvas(stage.canvas, touch.clientX, touch.clientY); stage._listeners.lastPointerPos = pos; // before touchstart event, fire a move event to better emulate cursor events // Language translation of this project into Chinese by Nianbroken if (type === 'start') stage.pointerEvent('move', pos.x / stage.dpr, pos.y / stage.dpr); }else{ // on touchend, fill in position information based on last known touch location pos = stage._listeners.lastPointerPos; } stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr); } }); }; // dispatch a normalized pointer event on a specific stage Stage.prototype.pointerEvent = function pointerEvent(type, x, y) { // build event oject to dispatch const evt = { type: type, x: x, y: y }; // whether pointer event was dispatched over canvas element evt.onCanvas = (x >= 0 && x = 0 && y"},{"title":"","date":"2023-01-21T11:54:52.019Z","updated":"2022-02-03T08:49:41.312Z","comments":true,"path":"FIREWORKS/js/fscreen.js","permalink":"http://www.angforever.top/FIREWORKS/js/fscreen.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ (function(global) { 'use strict'; var key = { fullscreenEnabled: 0, fullscreenElement: 1, requestFullscreen: 2, exitFullscreen: 3, fullscreenchange: 4, fullscreenerror: 5 }; var webkit = ['webkitFullscreenEnabled', 'webkitFullscreenElement', 'webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitfullscreenchange', 'webkitfullscreenerror']; var moz = ['mozFullScreenEnabled', 'mozFullScreenElement', 'mozRequestFullScreen', 'mozCancelFullScreen', 'mozfullscreenchange', 'mozfullscreenerror']; var ms = ['msFullscreenEnabled', 'msFullscreenElement', 'msRequestFullscreen', 'msExitFullscreen', 'MSFullscreenChange', 'MSFullscreenError']; // so it doesn't throw if no window or document // The language of this project was translated into Chinese by Nianbroken var doc = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {}; var vendor = 'fullscreenEnabled' in doc && Object.keys(key) || webkit[0] in doc && webkit || moz[0] in doc && moz || ms[0] in doc && ms || []; var fscreen = { requestFullscreen: function requestFullscreen(element) { return element[vendor[key.requestFullscreen]](); }, requestFullscreenFunction: function requestFullscreenFunction(element) { return element[vendor[key.requestFullscreen]]; }, get exitFullscreen() { return doc[vendor[key.exitFullscreen]].bind(doc); }, addEventListener: function addEventListener(type, handler, options) { return doc.addEventListener(vendor[key[type]], handler, options); }, removeEventListener: function removeEventListener(type, handler) { return doc.removeEventListener(vendor[key[type]], handler); }, get fullscreenEnabled() { return Boolean(doc[vendor[key.fullscreenEnabled]]); }, set fullscreenEnabled(val) {}, get fullscreenElement() { return doc[vendor[key.fullscreenElement]]; }, set fullscreenElement(val) {}, get onfullscreenchange() { return doc[('on' + vendor[key.fullscreenchange]).toLowerCase()]; }, set onfullscreenchange(handler) { return doc[('on' + vendor[key.fullscreenchange]).toLowerCase()] = handler; }, get onfullscreenerror() { return doc[('on' + vendor[key.fullscreenerror]).toLowerCase()]; }, set onfullscreenerror(handler) { return doc[('on' + vendor[key.fullscreenerror]).toLowerCase()] = handler; } }; global.fscreen = fscreen; })(window);"},{"title":"","date":"2023-01-21T11:54:52.222Z","updated":"2022-02-03T08:59:15.816Z","comments":true,"path":"FIREWORKS/js/script.js","permalink":"http://www.angforever.top/FIREWORKS/js/script.js","excerpt":"","text":"/* Ê≠§Ê∫êÁ†ÅÊòØÂü∫‰∫é XgpNwb ÁöÑ‰∫åÊ¨°‰øÆÊîπ GithubÔºöhttps://github.com/NianBroken/Firework_Simulator GiteeÔºöhttps://gitee.com/nianbroken/Firework_Simulator */ 'use strict'; console.clear(); // This is a prime example of what starts out as a simple project // and snowballs way beyond its intended size. It's a little clunky // reading/working on this single file, but here it is anyways :) const IS_MOBILE = window.innerWidth 800; const IS_HEADER = IS_DESKTOP && window.innerHeight < 300; // Detect high end devices. This will be a moving target. const IS_HIGH_END_DEVICE = (() => { const hwConcurrency = navigator.hardwareConcurrency; if (!hwConcurrency) { return false; } // Large screens indicate a full size computer, which often have hyper threading these days. // So a quad core desktop machine has 8 cores. We'll place a higher min threshold there. const minCount = window.innerWidth = minCount; })(); // Prevent canvases from getting too large on ridiculous screen sizes. // 8K - can restrict this if needed const MAX_WIDTH = 7680; const MAX_HEIGHT = 4320; const GRAVITY = 0.9; // Acceleration in px/s let simSpeed = 1; function getDefaultScaleFactor() { if (IS_MOBILE) return 0.9; if (IS_HEADER) return 0.75; return 1; } // Width/height values that take scale into account. // USE THESE FOR DRAWING POSITIONS let stageW, stageH; // All quality globals will be overwritten and updated via `configDidUpdate`. let quality = 1; let isLowQuality = false; let isNormalQuality = true; let isHighQuality = false; const QUALITY_LOW = 1; const QUALITY_NORMAL = 2; const QUALITY_HIGH = 3; const SKY_LIGHT_NONE = 0; const SKY_LIGHT_DIM = 1; const SKY_LIGHT_NORMAL = 2; const COLOR = { Red: '#ff0043', Green: '#14fc56', Blue: '#1e7fff', Purple: '#e60aff', Gold: '#ffbf36', White: '#ffffff' }; // Special invisible color (not rendered, and therefore not in COLOR map) const INVISIBLE = '_INVISIBLE_'; const PI_2 = Math.PI * 2; const PI_HALF = Math.PI * 0.5; // Stage.disableHighDPI = true; const trailsStage = new Stage('trails-canvas'); const mainStage = new Stage('main-canvas'); const stages = [ trailsStage, mainStage ]; // Fullscreen helpers, using Fscreen for prefixes. function fullscreenEnabled() { return fscreen.fullscreenEnabled; } // Note that fullscreen state is synced to store, and the store should be the source // of truth for whether the app is in fullscreen mode or not. function isFullscreen() { return !!fscreen.fullscreenElement; } // Attempt to toggle fullscreen mode. function toggleFullscreen() { if (fullscreenEnabled()) { if (isFullscreen()) { fscreen.exitFullscreen(); } else { fscreen.requestFullscreen(document.documentElement); } } } // Sync fullscreen changes with store. An event listener is necessary because the user can // toggle fullscreen mode directly through the browser, and we want to react to that. // The language of this project was translated into Chinese by Nianbroken fscreen.addEventListener('fullscreenchange', () => { store.setState({ fullscreen: isFullscreen() }); }); // Simple state container; the source of truth. const store = { _listeners: new Set(), _dispatch(prevState) { this._listeners.forEach(listener => listener(this.state, prevState)) }, state: { // will be unpaused in init() paused: true, soundEnabled: true, menuOpen: false, openHelpTopic: null, fullscreen: isFullscreen(), // Note that config values used for s must be strings, unless manually converting values to strings // at render time, and parsing on change. config: { quality: String(IS_HIGH_END_DEVICE ? QUALITY_HIGH : QUALITY_NORMAL), // will be mirrored to a global variable named `quality` in `configDidUpdate`, for perf. shell: 'Random', size: IS_DESKTOP ? '3' // Desktop default : IS_HEADER ? '1.2' // Profile header default (doesn't need to be an int) : '2', // Mobile default autoLaunch: true, finale: true, skyLighting: SKY_LIGHT_NORMAL + '', hideControls: IS_HEADER, longExposure: false, scaleFactor: getDefaultScaleFactor() } }, setState(nextState) { const prevState = this.state; this.state = Object.assign({}, this.state, nextState); this._dispatch(prevState); this.persist(); }, subscribe(listener) { this._listeners.add(listener); return () => this._listeners.remove(listener); }, // Load / persist select state to localStorage // Mutates state because `store.load()` should only be called once immediately after store is created, before any subscriptions. load() { const serializedData = localStorage.getItem('cm_fireworks_data'); if (serializedData) { const { schemaVersion, data } = JSON.parse(serializedData); const config = this.state.config; switch(schemaVersion) { case '1.1': config.quality = data.quality; config.size = data.size; config.skyLighting = data.skyLighting; break; case '1.2': config.quality = data.quality; config.size = data.size; config.skyLighting = data.skyLighting; config.scaleFactor = data.scaleFactor; break; default: throw new Error('version switch should be exhaustive'); } console.log(`Loaded config (schema version ${schemaVersion})`); } // Deprecated data format. Checked with care (it's not namespaced). else if (localStorage.getItem('schemaVersion') === '1') { let size; // Attempt to parse data, ignoring if there is an error. try { const sizeRaw = localStorage.getItem('configSize'); size = typeof sizeRaw === 'string' && JSON.parse(sizeRaw); } catch(e) { console.log('Recovered from error parsing saved config:'); console.error(e); return; } // Only restore validated values const sizeInt = parseInt(size, 10); if (sizeInt >= 0 && sizeInt !state.paused && !state.menuOpen; // Whether user has enabled sound. const soundEnabledSelector = (state=store.state) => state.soundEnabled; // Whether any sounds are allowed, taking into account multiple factors. const canPlaySoundSelector = (state=store.state) => isRunning(state) && soundEnabledSelector(state); // Convert quality to number. const qualitySelector = () => +store.state.config.quality; const shellNameSelector = () => store.state.config.shell; // Convert shell size to number. const shellSizeSelector = () => +store.state.config.size; const finaleSelector = () => store.state.config.finale; const skyLightingSelector = () => +store.state.config.skyLighting; const scaleFactorSelector = () => store.state.config.scaleFactor; // Help Content const helpContent = { shellType: { header: 'ÁÉüËä±Á±ªÂûã', body: '‰Ω†Ë¶ÅÊîæÁöÑÁÉüËä±ÁöÑÁ±ªÂûãÔºåÈÄâÊã©‚ÄúÈöèÊú∫ÔºàRandomÔºâ‚ÄùÂèØ‰ª•Ëé∑ÂæóÈùûÂ∏∏Â•ΩÁöÑ‰ΩìÈ™åÔºÅ' }, shellSize: { header: 'ÁÉüËä±Â§ßÂ∞è', body: 'ÁÉüËä±Ë∂äÂ§ßÁªΩÊîæËåÉÂõ¥Â∞±Ë∂äÂ§ßÔºå‰ΩÜÊòØÁÉüËä±Ë∂äÂ§ßÔºåËÆæÂ§áÊâÄÈúÄÁöÑÊÄßËÉΩ‰πü‰ºöÂ¢ûÂ§öÔºåÂ§ßÁöÑÁÉüËä±ÂèØËÉΩÂØºËá¥‰Ω†ÁöÑËÆæÂ§áÂç°È°ø„ÄÇ' }, quality: { header: 'ÁîªË¥®', body: 'Â¶ÇÊûúÂä®ÁîªËøêË°å‰∏çÊµÅÁïÖÔºå‰Ω†ÂèØ‰ª•ËØïËØïÈôç‰ΩéÁîªË¥®„ÄÇÁîªË¥®Ë∂äÈ´òÔºåÁÉüËä±ÁªΩÊîæÂêéÁöÑÁÅ´Ëä±Êï∞ÈáèÂ∞±Ë∂äÂ§öÔºå‰ΩÜÈ´òÁîªË¥®ÂèØËÉΩÂØºËá¥‰Ω†ÁöÑËÆæÂ§áÂç°È°ø„ÄÇ' }, skyLighting: { header: 'ÁÖß‰∫ÆÂ§©Á©∫', body: 'ÁÉüËä±ÁàÜÁÇ∏Êó∂ÔºåËÉåÊôØ‰ºöË¢´ÁÖß‰∫Æ„ÄÇÂ¶ÇÊûú‰Ω†ÁöÑÂ±èÂπïÁúãËµ∑Êù•Â§™‰∫Æ‰∫ÜÔºåÂèØ‰ª•ÊääÂÆÉÊîπÊàê‚ÄúÊöó‚ÄùÊàñËÄÖ‚Äú‰∏ç‚Äù„ÄÇ' }, scaleFactor: { header: 'Áº©Êîæ', body: '‰Ωø‰Ω†‰∏éÁÉüËä±Á¶ªÂæóÊõ¥ËøëÊàñÊõ¥Ëøú„ÄÇÂØπ‰∫éËæÉÂ§ßÁöÑÁÉüËä±Ôºå‰Ω†ÂèØ‰ª•ÈÄâÊã©Êõ¥Â∞èÁöÑÁº©ÊîæÂÄºÔºåÂ∞§ÂÖ∂ÊòØÂú®ÊâãÊú∫ÊàñÂπ≥ÊùøÁîµËÑë‰∏ä„ÄÇ' }, autoLaunch: { header: 'Ëá™Âä®ÊîæÁÉüËä±', body: 'ÂºÄÂêØÂêé‰Ω†Â∞±ÂèØ‰ª•ÂùêÂú®‰Ω†ÁöÑËÆæÂ§áÂ±èÂπïÂâçÈù¢Ê¨£ËµèÁÉüËä±‰∫ÜÔºå‰Ω†‰πüÂèØ‰ª•ÂÖ≥Èó≠ÂÆÉÔºå‰ΩÜÂÖ≥Èó≠Âêé‰Ω†Â∞±Âè™ËÉΩÈÄöËøáÁÇπÂáªÂ±èÂπïÁöÑÊñπÂºèÊù•ÊîæÁÉüËä±„ÄÇ' }, finaleMode: { header: 'ÂêåÊó∂ÊîæÊõ¥Â§öÁöÑÁÉüËä±', body: 'ÂèØ‰ª•Âú®Âêå‰∏ÄÊó∂Èó¥Ëá™Âä®ÊîæÂá∫Êõ¥Â§öÁöÑÁÉüËä±Ôºà‰ΩÜÈúÄË¶ÅÂºÄÂêØÂÖàÂºÄÂêØ‚ÄúËá™Âä®ÊîæÁÉüËä±‚ÄùÔºâ„ÄÇ' }, hideControls: { header: 'ÈöêËóèÊéßÂà∂ÊåâÈíÆ', body: 'ÈöêËóèÂ±èÂπïÈ°∂ÈÉ®ÁöÑÊåâÈíÆ„ÄÇÂ¶ÇÊûú‰Ω†Ë¶ÅÊà™ÂõæÔºåÊàñËÄÖÈúÄË¶Å‰∏Ä‰∏™Êó†ÁºùÁöÑ‰ΩìÈ™åÔºå‰Ω†Â∞±ÂèØ‰ª•Â∞ÜÊåâÈíÆÈöêËóèÔºåÈöêËóèÊåâÈíÆÂêé‰Ω†‰ªçÁÑ∂ÂèØ‰ª•Âú®Âè≥‰∏äËßíÊâìÂºÄËÆæÁΩÆ„ÄÇ' }, fullscreen: { header: 'ÂÖ®Â±è', body: 'ÂàáÊç¢Ëá≥ÂÖ®Â±èÊ®°Âºè' }, longExposure: { header: '‰øùÁïôÁÉüËä±ÁöÑÁÅ´Ëä±', body: 'ÂèØ‰ª•‰øùÁïôÁÉüËä±Áïô‰∏ãÁöÑÁÅ´Ëä±' } }; const nodeKeyToHelpKey = { shellTypeLabel: 'shellType', shellSizeLabel: 'shellSize', qualityLabel: 'quality', skyLightingLabel: 'skyLighting', scaleFactorLabel: 'scaleFactor', autoLaunchLabel: 'autoLaunch', finaleModeLabel: 'finaleMode', hideControlsLabel: 'hideControls', fullscreenLabel: 'fullscreen', longExposureLabel: 'longExposure' }; // Render app UI / keep in sync with state const appNodes = { stageContainer: '.stage-container', canvasContainer: '.canvas-container', controls: '.controls', menu: '.menu', menuInnerWrap: '.menu__inner-wrap', pauseBtn: '.pause-btn', pauseBtnSVG: '.pause-btn use', soundBtn: '.sound-btn', soundBtnSVG: '.sound-btn use', shellType: '.shell-type', shellTypeLabel: '.shell-type-label', shellSize: '.shell-size', shellSizeLabel: '.shell-size-label', quality: '.quality-ui', qualityLabel: '.quality-ui-label', skyLighting: '.sky-lighting', skyLightingLabel: '.sky-lighting-label', scaleFactor: '.scaleFactor', scaleFactorLabel: '.scaleFactor-label', autoLaunch: '.auto-launch', autoLaunchLabel: '.auto-launch-label', finaleModeFormOption: '.form-option--finale-mode', finaleMode: '.finale-mode', finaleModeLabel: '.finale-mode-label', hideControls: '.hide-controls', hideControlsLabel: '.hide-controls-label', fullscreenFormOption: '.form-option--fullscreen', fullscreen: '.fullscreen', fullscreenLabel: '.fullscreen-label', longExposure: '.long-exposure', longExposureLabel: '.long-exposure-label', // Help UI helpModal: '.help-modal', helpModalOverlay: '.help-modal__overlay', helpModalHeader: '.help-modal__header', helpModalBody: '.help-modal__body', helpModalCloseBtn: '.help-modal__close-btn' }; // Convert appNodes selectors to dom nodes Object.keys(appNodes).forEach(key => { appNodes[key] = document.querySelector(appNodes[key]); }); // Remove fullscreen control if not supported. if (!fullscreenEnabled()) { appNodes.fullscreenFormOption.classList.add('remove'); } // First render is called in init() function renderApp(state) { const pauseBtnIcon = `#icon-${state.paused ? 'play' : 'pause'}`; const soundBtnIcon = `#icon-sound-${soundEnabledSelector() ? 'on' : 'off'}`; appNodes.pauseBtnSVG.setAttribute('href', pauseBtnIcon); appNodes.pauseBtnSVG.setAttribute('xlink:href', pauseBtnIcon); appNodes.soundBtnSVG.setAttribute('href', soundBtnIcon); appNodes.soundBtnSVG.setAttribute('xlink:href', soundBtnIcon); appNodes.controls.classList.toggle('hide', state.menuOpen || state.config.hideControls); appNodes.canvasContainer.classList.toggle('blur', state.menuOpen); appNodes.menu.classList.toggle('hide', !state.menuOpen); appNodes.finaleModeFormOption.style.opacity = state.config.autoLaunch ? 1 : 0.32; appNodes.quality.value = state.config.quality; appNodes.shellType.value = state.config.shell; appNodes.shellSize.value = state.config.size; appNodes.autoLaunch.checked = state.config.autoLaunch; appNodes.finaleMode.checked = state.config.finale; appNodes.skyLighting.value = state.config.skyLighting; appNodes.hideControls.checked = state.config.hideControls; appNodes.fullscreen.checked = state.fullscreen; appNodes.longExposure.checked = state.config.longExposure; appNodes.scaleFactor.value = state.config.scaleFactor.toFixed(2); appNodes.menuInnerWrap.style.opacity = state.openHelpTopic ? 0.12 : 1; appNodes.helpModal.classList.toggle('active', !!state.openHelpTopic); if (state.openHelpTopic) { const { header, body } = helpContent[state.openHelpTopic]; appNodes.helpModalHeader.textContent = header; appNodes.helpModalBody.textContent = body; } } store.subscribe(renderApp); // Perform side effects on state changes function handleStateChange(state, prevState) { const canPlaySound = canPlaySoundSelector(state); const canPlaySoundPrev = canPlaySoundSelector(prevState); if (canPlaySound !== canPlaySoundPrev) { if (canPlaySound) { soundManager.resumeAll(); } else { soundManager.pauseAll(); } } } store.subscribe(handleStateChange); function getConfigFromDOM() { return { quality: appNodes.quality.value, shell: appNodes.shellType.value, size: appNodes.shellSize.value, autoLaunch: appNodes.autoLaunch.checked, finale: appNodes.finaleMode.checked, skyLighting: appNodes.skyLighting.value, longExposure: appNodes.longExposure.checked, hideControls: appNodes.hideControls.checked, // Store value as number. scaleFactor: parseFloat(appNodes.scaleFactor.value) }; }; const updateConfigNoEvent = () => updateConfig(); appNodes.quality.addEventListener('input', updateConfigNoEvent); appNodes.shellType.addEventListener('input', updateConfigNoEvent); appNodes.shellSize.addEventListener('input', updateConfigNoEvent); appNodes.autoLaunch.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.finaleMode.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.skyLighting.addEventListener('input', updateConfigNoEvent); appNodes.longExposure.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.hideControls.addEventListener('click', () => setTimeout(updateConfig, 0)); appNodes.fullscreen.addEventListener('click', () => setTimeout(toggleFullscreen, 0)); // Changing scaleFactor requires triggering resize handling code as well. appNodes.scaleFactor.addEventListener('input', () => { updateConfig(); handleResize(); }); Object.keys(nodeKeyToHelpKey).forEach(nodeKey => { const helpKey = nodeKeyToHelpKey[nodeKey]; appNodes[nodeKey].addEventListener('click', () => { store.setState({ openHelpTopic: helpKey }); }); }); appNodes.helpModalCloseBtn.addEventListener('click', () => { store.setState({ openHelpTopic: null }); }); appNodes.helpModalOverlay.addEventListener('click', () => { store.setState({ openHelpTopic: null }); }); // Constant derivations const COLOR_NAMES = Object.keys(COLOR); const COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]); // Invisible stars need an indentifier, even through they won't be rendered - physics still apply. const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE]; // Map of color codes to their index in the array. Useful for quickly determining if a color has already been updated in a loop. const COLOR_CODE_INDEXES = COLOR_CODES_W_INVIS.reduce((obj, code, i) => { obj[code] = i; return obj; }, {}); // Tuples is a map keys by color codes (hex) with values of { r, g, b } tuples (still just objects). const COLOR_TUPLES = {}; COLOR_CODES.forEach(hex => { COLOR_TUPLES[hex] = { r: parseInt(hex.substr(1, 2), 16), g: parseInt(hex.substr(3, 2), 16), b: parseInt(hex.substr(5, 2), 16), }; }); // Get a random color. function randomColorSimple() { return COLOR_CODES[Math.random() * COLOR_CODES.length | 0]; } // Get a random color, with some customization options available. let lastColor; function randomColor(options) { const notSame = options && options.notSame; const notColor = options && options.notColor; const limitWhite = options && options.limitWhite; let color = randomColorSimple(); // limit the amount of white chosen randomly if (limitWhite && color === COLOR.White && Math.random() < 0.6) { color = randomColorSimple(); } if (notSame) { while (color === lastColor) { color = randomColorSimple(); } } else if (notColor) { while (color === notColor) { color = randomColorSimple(); } } lastColor = color; return color; } function whiteOrGold() { return Math.random() < 0.5 ? COLOR.Gold : COLOR.White; } // Shell helpers function makePistilColor(shellColor) { return (shellColor === COLOR.White || shellColor === COLOR.Gold) ? randomColor({ notColor: shellColor }) : whiteOrGold(); } // Unique shell types const crysanthemumShell = (size=1) => { const glitter = Math.random() < 0.25; const singleColor = Math.random() < 0.72; const color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })]; const pistil = singleColor && Math.random() < 0.42; const pistilColor = pistil && makePistilColor(color); const secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({ notColor: color, limitWhite: true }) : null; const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42; let starDensity = glitter ? 1.1 : 1.25; if (isLowQuality) starDensity *= 0.8; if (isHighQuality) starDensity = 1.2; return { shellSize: size, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starDensity, color, secondColor, glitter: glitter ? 'light' : '', glitterColor: whiteOrGold(), pistil, pistilColor, streamers }; }; const ghostShell = (size=1) => { // Extend crysanthemum shell const shell = crysanthemumShell(size); // Ghost effect can be fast, so extend star life shell.starLife *= 1.5; // Ensure we always have a single color other than white let ghostColor = randomColor({ notColor: COLOR.White }); // Always use streamers, and sometimes a pistil shell.streamers = true; const pistil = Math.random() < 0.42; const pistilColor = pistil && makePistilColor(ghostColor); // Ghost effect - transition from invisible to chosen color shell.color = INVISIBLE; shell.secondColor = ghostColor; // We don't want glitter to be spewed by invisible stars, and we don't currently // have a way to transition glitter state. So we'll disable it. shell.glitter = ''; return shell; }; const strobeShell = (size=1) => { const color = randomColor({ limitWhite: true }); return { shellSize: size, spreadSize: 280 + size * 92, starLife: 1100 + size * 200, starLifeVariation: 0.40, starDensity: 1.1, color, glitter: 'light', glitterColor: COLOR.White, strobe: true, strobeColor: Math.random() < 0.5 ? COLOR.White : null, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color) }; }; const palmShell = (size=1) => { const color = randomColor(); const thick = Math.random() < 0.5; return { shellSize: size, color, spreadSize: 250 + size * 75, starDensity: thick ? 0.15 : 0.4, starLife: 1800 + size * 200, glitter: thick ? 'thick' : 'heavy' }; }; const ringShell = (size=1) => { const color = randomColor(); const pistil = Math.random() < 0.75; return { shellSize: size, ring: true, color, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starCount: 2.2 * PI_2 * (size+1), pistil, pistilColor: makePistilColor(color), glitter: !pistil ? 'light' : '', glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White, streamers: Math.random() < 0.3 }; // return Object.assign({}, defaultShell, config); }; const crossetteShell = (size=1) => { const color = randomColor({ limitWhite: true }); return { shellSize: size, spreadSize: 300 + size * 100, starLife: 750 + size * 160, starLifeVariation: 0.4, starDensity: 0.85, color, crossette: true, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color) }; }; const floralShell = (size=1) => ({ shellSize: size, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, color: Math.random() < 0.65 ? 'random' : (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })]), floral: true }); const fallingLeavesShell = (size=1) => ({ shellSize: size, color: INVISIBLE, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, glitter: 'medium', glitterColor: COLOR.Gold, fallingLeaves: true }); const willowShell = (size=1) => ({ shellSize: size, spreadSize: 300 + size * 100, starDensity: 0.6, starLife: 3000 + size * 300, glitter: 'willow', glitterColor: COLOR.Gold, color: INVISIBLE }); const crackleShell = (size=1) => { // favor gold const color = Math.random() < 0.75 ? COLOR.Gold : randomColor(); return { shellSize: size, spreadSize: 380 + size * 75, starDensity: isLowQuality ? 0.65 : 1, starLife: 600 + size * 100, starLifeVariation: 0.32, glitter: 'light', glitterColor: COLOR.Gold, color, crackle: true, pistil: Math.random() < 0.65, pistilColor: makePistilColor(color) }; }; const horsetailShell = (size=1) => { const color = randomColor(); return { shellSize: size, horsetail: true, color, spreadSize: 250 + size * 38, starDensity: 0.9, starLife: 2500 + size * 300, glitter: 'medium', glitterColor: Math.random() < 0.5 ? whiteOrGold() : color, // Add strobe effect to white horsetails, to make them more interesting strobe: color === COLOR.White }; }; function randomShellName() { return Math.random() < 0.5 ? 'Crysanthemum' : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0 ]; } function randomShell(size) { // Special selection for codepen header. if (IS_HEADER) return randomFastShell()(size); // Normal operation return shellTypes[randomShellName()](size); } function shellFromConfig(size) { return shellTypes[shellNameSelector()](size); } // Get a random shell, not including processing intensive varients // Note this is only random when \"Random\" shell is selected in config. // Also, this does not create the shell, only returns the factory function. const fastShellBlacklist = ['Falling Leaves', 'Floral', 'Willow']; function randomFastShell() { const isRandom = shellNameSelector() === 'Random'; let shellName = isRandom ? randomShellName() : shellNameSelector(); if (isRandom) { while (fastShellBlacklist.includes(shellName)) { shellName = randomShellName(); } } return shellTypes[shellName]; } const shellTypes = { 'Random': randomShell, 'Crackle': crackleShell, 'Crossette': crossetteShell, 'Crysanthemum': crysanthemumShell, 'Falling Leaves': fallingLeavesShell, 'Floral': floralShell, 'Ghost': ghostShell, 'Horse Tail': horsetailShell, 'Palm': palmShell, 'Ring': ringShell, 'Strobe': strobeShell, 'Willow': willowShell }; const shellNames = Object.keys(shellTypes); function init() { // Remove loading state document.querySelector('.loading-init').remove(); appNodes.stageContainer.classList.remove('remove'); // Populate dropdowns function setOptionsForSelect(node, options) { node.innerHTML = options.reduce((acc, opt) => acc += `${opt.label}`, ''); } // shell type let options = ''; shellNames.forEach(opt => options += `${opt}`); appNodes.shellType.innerHTML = options; // shell size options = ''; ['3\"', '4\"', '6\"', '8\"', '12\"', '16\"'].forEach((opt, i) => options += `${opt}`); appNodes.shellSize.innerHTML = options; setOptionsForSelect(appNodes.quality, [ { label: '‰Ωé', value: QUALITY_LOW }, { label: 'Ê≠£Â∏∏', value: QUALITY_NORMAL }, { label: 'È´ò', value: QUALITY_HIGH } ]); setOptionsForSelect(appNodes.skyLighting, [ { label: '‰∏ç', value: SKY_LIGHT_NONE }, { label: 'Êöó', value: SKY_LIGHT_DIM }, { label: 'Ê≠£Â∏∏', value: SKY_LIGHT_NORMAL } ]); // 0.9 is mobile default setOptionsForSelect( appNodes.scaleFactor, [0.5, 0.62, 0.75, 0.9, 1.0, 1.5, 2.0] .map(value => ({ value: value.toFixed(2), label: `${value*100}%` })) ); // Begin simulation togglePause(false); // initial render renderApp(store.state); // Apply initial config configDidUpdate(); } function fitShellPositionInBoundsH(position) { const edge = 0.18; return (1 - edge*2) * position + edge; } function fitShellPositionInBoundsV(position) { return position * 0.75; } function getRandomShellPositionH() { return fitShellPositionInBoundsH(Math.random()); } function getRandomShellPositionV() { return fitShellPositionInBoundsV(Math.random()); } function getRandomShellSize() { const baseSize = shellSizeSelector(); const maxVariance = Math.min(2.5, baseSize); const variance = Math.random() * maxVariance; const size = baseSize - variance; const height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance); const centerOffset = Math.random() * (1 - height * 0.65) * 0.5; const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset; return { size, x: fitShellPositionInBoundsH(x), height: fitShellPositionInBoundsV(height) }; } // Launches a shell from a user pointer event, based on state.config function launchShellFromConfig(event) { const shell = new Shell(shellFromConfig(shellSizeSelector())); const w = mainStage.width; const h = mainStage.height; shell.launch( event ? event.x / w : getRandomShellPositionH(), event ? 1 - event.y / h : getRandomShellPositionV() ); } // Sequences // ----------- function seqRandomShell() { const size = getRandomShellSize(); const shell = new Shell(shellFromConfig(size.size)); shell.launch(size.x, size.height); let extraDelay = shell.starLife; if (shell.fallingLeaves) { extraDelay = 4600; } return 900 + Math.random() * 600 + extraDelay; } function seqRandomFastShell() { const shellType = randomFastShell(); const size = getRandomShellSize(); const shell = new Shell(shellType(size.size)); shell.launch(size.x, size.height); let extraDelay = shell.starLife; return 900 + Math.random() * 600 + extraDelay; } function seqTwoRandom() { const size1 = getRandomShellSize(); const size2 = getRandomShellSize(); const shell1 = new Shell(shellFromConfig(size1.size)); const shell2 = new Shell(shellFromConfig(size2.size)); const leftOffset = Math.random() * 0.2 - 0.1; const rightOffset = Math.random() * 0.2 - 0.1; shell1.launch(0.3 + leftOffset, size1.height); setTimeout(() => { shell2.launch(0.7 + rightOffset, size2.height); }, 100); let extraDelay = Math.max(shell1.starLife, shell2.starLife); if (shell1.fallingLeaves || shell2.fallingLeaves) { extraDelay = 4600; } return 900 + Math.random() * 600 + extraDelay; } function seqTriple() { const shellType = randomFastShell(); const baseSize = shellSizeSelector(); const smallSize = Math.max(0, baseSize - 1.25); const offset = Math.random() * 0.08 - 0.04; const shell1 = new Shell(shellType(baseSize)); shell1.launch(0.5 + offset, 0.7); const leftDelay = 1000 + Math.random() * 400; const rightDelay = 1000 + Math.random() * 400; setTimeout(() => { const offset = Math.random() * 0.08 - 0.04; const shell2 = new Shell(shellType(smallSize)); shell2.launch(0.2 + offset, 0.1); }, leftDelay); setTimeout(() => { const offset = Math.random() * 0.08 - 0.04; const shell3 = new Shell(shellType(smallSize)); shell3.launch(0.8 + offset, 0.1); }, rightDelay); return 4000; } function seqPyramid() { const barrageCountHalf = IS_DESKTOP ? 7 : 4; const largeSize = shellSizeSelector(); const smallSize = Math.max(0, largeSize - 3); const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell; const randomSpecialShell = randomShell; function launchShell(x, useSpecial) { const isRandom = shellNameSelector() === 'Random'; let shellType = isRandom ? useSpecial ? randomSpecialShell : randomMainShell : shellTypes[shellNameSelector()]; const shell = new Shell(shellType(useSpecial ? largeSize : smallSize)); const height = x { launchShell(offset, false); }, delay); setTimeout(() => { launchShell(1 - offset, false); }, delay + delayOffset); } count++; delay += 200; } return 3400 + barrageCountHalf * 250; } function seqSmallBarrage() { seqSmallBarrage.lastCalled = Date.now(); const barrageCount = IS_DESKTOP ? 11 : 5; const specialIndex = IS_DESKTOP ? 3 : 1; const shellSize = Math.max(0, shellSizeSelector() - 2); const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell; const randomSpecialShell = randomFastShell(); // (cos(x*5œÄ+0.5œÄ)+1)/2 is a custom wave bounded by 0 and 1 used to set varying launch heights function launchShell(x, useSpecial) { const isRandom = shellNameSelector() === 'Random'; let shellType = isRandom ? useSpecial ? randomSpecialShell : randomMainShell : shellTypes[shellNameSelector()]; const shell = new Shell(shellType(shellSize)); const height = (Math.cos(x*5*Math.PI + PI_HALF) + 1) / 2; shell.launch(x, height * 0.75); } let count = 0; let delay = 0; while(count < barrageCount) { if (count === 0) { launchShell(0.5, false) count += 1; } else { const offset = (count + 1) / barrageCount / 2; const delayOffset = Math.random() * 30 + 30; const useSpecial = count === specialIndex; setTimeout(() => { launchShell(0.5 + offset, useSpecial); }, delay); setTimeout(() => { launchShell(0.5 - offset, useSpecial); }, delay + delayOffset); count += 2; } delay += 200; } return 3400 + barrageCount * 120; } seqSmallBarrage.cooldown = 15000; seqSmallBarrage.lastCalled = Date.now(); const sequences = [ seqRandomShell, seqTwoRandom, seqTriple, seqPyramid, seqSmallBarrage ]; let isFirstSeq = true; const finaleCount = 32; let currentFinaleCount = 0; function startSequence() { if (isFirstSeq) { isFirstSeq = false; if (IS_HEADER) { return seqTwoRandom(); } else { const shell = new Shell(crysanthemumShell(shellSizeSelector())); shell.launch(0.5, 0.5); return 2400; } } if (finaleSelector()) { seqRandomFastShell(); if (currentFinaleCount < finaleCount) { currentFinaleCount++; return 170; } else { currentFinaleCount = 0; return 6000; } } const rand = Math.random(); if (rand < 0.08 && Date.now() - seqSmallBarrage.lastCalled > seqSmallBarrage.cooldown) { return seqSmallBarrage(); } if (rand < 0.1) { return seqPyramid(); } if (rand < 0.6 && !IS_HEADER) { return seqRandomShell(); } else if (rand < 0.8) { return seqTwoRandom(); } else if (rand < 1) { return seqTriple(); } } let activePointerCount = 0; let isUpdatingSpeed = false; function handlePointerStart(event) { activePointerCount++; const btnSize = 50; if (event.y < btnSize) { if (event.x < btnSize) { togglePause(); return; } if (event.x > mainStage.width/2 - btnSize/2 && event.x < mainStage.width/2 + btnSize/2) { toggleSound(); return; } if (event.x > mainStage.width - btnSize) { toggleMenu(); return; } } if (!isRunning()) return; if (updateSpeedFromEvent(event)) { isUpdatingSpeed = true; } else if (event.onCanvas) { launchShellFromConfig(event); } } function handlePointerEnd(event) { activePointerCount--; isUpdatingSpeed = false; } function handlePointerMove(event) { if (!isRunning()) return; if (isUpdatingSpeed) { updateSpeedFromEvent(event); } } function handleKeydown(event) { // P if (event.keyCode === 80) { togglePause(); } // O else if (event.keyCode === 79) { toggleMenu(); } // Esc else if (event.keyCode === 27) { toggleMenu(false); } } mainStage.addEventListener('pointerstart', handlePointerStart); mainStage.addEventListener('pointerend', handlePointerEnd); mainStage.addEventListener('pointermove', handlePointerMove); window.addEventListener('keydown', handleKeydown); // Account for window resize and custom scale changes. function handleResize() { const w = window.innerWidth; const h = window.innerHeight; // Try to adopt screen size, heeding maximum sizes specified const containerW = Math.min(w, MAX_WIDTH); // On small screens, use full device height const containerH = w stage.resize(containerW, containerH)); // Account for scale const scaleFactor = scaleFactorSelector(); stageW = containerW / scaleFactor; stageH = containerH / scaleFactor; } // Compute initial dimensions handleResize(); window.addEventListener('resize', handleResize); // Dynamic globals let currentFrame = 0; let speedBarOpacity = 0; let autoLaunchTime = 0; function updateSpeedFromEvent(event) { if (isUpdatingSpeed || event.y >= mainStage.height - 44) { // On phones it's hard to hit the edge pixels in order to set speed at 0 or 1, so some padding is provided to make that easier. const edge = 16; const newSpeed = (event.x - edge) / (mainStage.width - edge * 2); simSpeed = Math.min(Math.max(newSpeed, 0), 1); // show speed bar after an update speedBarOpacity = 1; // If we updated the speed, return true return true; } // Return false if the speed wasn't updated return false; } // Extracted function to keep `update()` optimized function updateGlobals(timeStep, lag) { currentFrame++; // Always try to fade out speed bar if (!isUpdatingSpeed) { speedBarOpacity -= lag / 30; // half a second if (speedBarOpacity < 0) { speedBarOpacity = 0; } } // auto launch shells if (store.state.config.autoLaunch) { autoLaunchTime -= timeStep; if (autoLaunchTime { // Stars const stars = Star.active[color]; for (let i=stars.length-1; i>=0; i=i-1) { const star = stars[i]; // Only update each star once per frame. Since color can change, it's possible a star could update twice without this, leading to a \"jump\". if (star.updateFrame === currentFrame) { continue; } star.updateFrame = currentFrame; star.life -= timeStep; if (star.life { const tuple = COLOR_TUPLES[color]; const count = Star.active[color].length; totalStarCount += count; targetSkyColor.r += tuple.r * count; targetSkyColor.g += tuple.g * count; targetSkyColor.b += tuple.b * count; }); // Clamp intensity at 1.0, and map to a custom non-linear curve. This allows few stars to perceivably light up the sky, while more stars continue to increase the brightness but at a lesser rate. This is more inline with humans' non-linear brightness perception. const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3); // Figure out which color component has the highest value, so we can scale them without affecting the ratios. // Prevent 0 from being used, so we don't divide by zero in the next step. const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b); // Scale all color components to a max of `maxSkySaturation`, and apply intensity. targetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity; targetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity; targetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity; // Animate changes to color to smooth out transitions. const colorChange = 10; currentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed; currentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed; currentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed; appNodes.canvasContainer.style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`; } mainStage.addEventListener('ticker', update); // Helper used to semi-randomly spread particles over an arc // Values are flexible - `start` and `arcLength` can be negative, and `randomness` is simply a multiplier for random addition. function createParticleArc(start, arcLength, count, randomness, particleFactory) { const angleDelta = arcLength / count; // Sometimes there is an extra particle at the end, too close to the start. Subtracting half the angleDelta ensures that is skipped. // Would be nice to fix this a better way. const end = start + arcLength - (angleDelta * 0.5); if (end > start) { // Optimization: `angle=angle+angleDelta` vs. angle+=angleDelta // V8 deoptimises with let compound assignment for (let angle=start; angleend; angle=angle+angleDelta) { particleFactory(angle + Math.random() * angleDelta * randomness); } } } /** * Helper used to create a spherical burst of particles. * * @param {Number} count The desired number of stars/particles. This value is a suggestion, and the * created burst may have more particles. The current algorithm can't perfectly * distribute a specific number of points evenly on a sphere's surface. * @param {Function} particleFactory Called once per star/particle generated. Passed two arguments: * `angle`: The direction of the star/particle. * `speed`: A multipler for the particle speed, from 0.0 to 1.0. * @param {Number} startAngle=0 For segmented bursts, you can generate only a partial arc of particles. This * allows setting the starting arc angle (radians). * @param {Number} arcLength=TAU The length of the arc (radians). Defaults to a full circle. * * @return {void} Returns nothing; it's up to `particleFactory` to use the given data. */ function createBurst(count, particleFactory, startAngle=0, arcLength=PI_2) { // Assuming sphere with surface area of `count`, calculate various // properties of said sphere (unit is stars). // Radius const R = 0.5 * Math.sqrt(count/Math.PI); // Circumference const C = 2 * R * Math.PI; // Half Circumference const C_HALF = C / 2; // Make a series of rings, sizing them as if they were spaced evenly // along the curved surface of a sphere. for (let i=0; i this.burst(comet.x, comet.y); soundManager.playSound('lift'); } burst(x, y) { // Set burst speed so overall burst grows to set size. This specific formula was derived from testing, and is affected by simulated air drag. const speed = this.spreadSize / 96; let color, onDeath, sparkFreq, sparkSpeed, sparkLife; let sparkLifeVariation = 0.25; // Some death effects, like crackle, play a sound, but should only be played once. let playedDeathSound = false; if (this.crossette) onDeath = (star) => { if (!playedDeathSound) { soundManager.playSound('crackleSmall'); playedDeathSound = true; } crossetteEffect(star); } if (this.crackle) onDeath = (star) => { if (!playedDeathSound) { soundManager.playSound('crackle'); playedDeathSound = true; } crackleEffect(star); } if (this.floral) onDeath = floralEffect; if (this.fallingLeaves) onDeath = fallingLeavesEffect; if (this.glitter === 'light') { sparkFreq = 400; sparkSpeed = 0.3; sparkLife = 300; sparkLifeVariation = 2; } else if (this.glitter === 'medium') { sparkFreq = 200; sparkSpeed = 0.44; sparkLife = 700; sparkLifeVariation = 2; } else if (this.glitter === 'heavy') { sparkFreq = 80; sparkSpeed = 0.8; sparkLife = 1400; sparkLifeVariation = 2; } else if (this.glitter === 'thick') { sparkFreq = 16; sparkSpeed = isHighQuality ? 1.65 : 1.5; sparkLife = 1400; sparkLifeVariation = 3; } else if (this.glitter === 'streamer') { sparkFreq = 32; sparkSpeed = 1.05; sparkLife = 620; sparkLifeVariation = 2; } else if (this.glitter === 'willow') { sparkFreq = 120; sparkSpeed = 0.34; sparkLife = 1400; sparkLifeVariation = 3.8; } // Apply quality to spark count sparkFreq = sparkFreq / quality; // Star factory for primary burst, pistils, and streamers. let firstStar = true; const starFactory = (angle, speedMult) => { // For non-horsetail shells, compute an initial vertical speed to add to star burst. // The magic number comes from testing what looks best. The ideal is that all shell // bursts appear visually centered for the majority of the star life (excl. willows etc.) const standardInitialSpeed = this.spreadSize / 1800; const star = Star.add( x, y, color || randomColor(), angle, speedMult * speed, // add minor variation to star life this.starLife + Math.random() * this.starLife * this.starLifeVariation, this.horsetail ? this.comet && this.comet.speedX : 0, this.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed ); if (this.secondColor) { star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32); star.secondColor = this.secondColor; } if (this.strobe) { star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46); star.strobe = true; // How many milliseconds between switch of strobe state \"tick\". Note that the strobe pattern // is on:off:off, so this is the \"on\" duration, while the \"off\" duration is twice as long. star.strobeFreq = Math.random() * 20 + 40; if (this.strobeColor) { star.secondColor = this.strobeColor; } } star.onDeath = onDeath; if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; } }; if (typeof this.color === 'string') { if (this.color === 'random') { color = null; // falsey value creates random color in starFactory } else { color = this.color; } // Rings have positional randomness, but are rotated randomly if (this.ring) { const ringStartAngle = Math.random() * Math.PI; const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;; createParticleArc(0, PI_2, this.starCount, 0, angle => { // Create a ring, squashed horizontally const initSpeedX = Math.sin(angle) * speed * ringSquash; const initSpeedY = Math.cos(angle) * speed; // Rotate ring const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY); const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle; const star = Star.add( x, y, color, newAngle, // apply near cubic falloff to speed (places more particles towards outside) newSpeed,//speed, // add minor variation to star life this.starLife + Math.random() * this.starLife * this.starLifeVariation ); if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; } }); } // Normal burst else { createBurst(this.starCount, starFactory); } } else if (Array.isArray(this.color)) { if (Math.random() < 0.5) { const start = Math.random() * Math.PI; const start2 = start + Math.PI; const arc = Math.PI; color = this.color[0]; // Not creating a full arc automatically reduces star count. createBurst(this.starCount, starFactory, start, arc); color = this.color[1]; createBurst(this.starCount, starFactory, start2, arc); } else { color = this.color[0]; createBurst(this.starCount / 2, starFactory); color = this.color[1]; createBurst(this.starCount / 2, starFactory); } } else { throw new Error('Invalid shell color. Expected string or array of strings, but got: ' + this.color); } if (this.pistil) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.5, starLife: this.starLife * 0.6, starLifeVariation: this.starLifeVariation, starDensity: 1.4, color: this.pistilColor, glitter: 'light', glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White }); innerShell.burst(x, y); } if (this.streamers) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.9, starLife: this.starLife * 0.8, starLifeVariation: this.starLifeVariation, starCount: Math.floor(Math.max(6, this.spreadSize / 45)), color: COLOR.White, glitter: 'streamer' }); innerShell.burst(x, y); } // Queue burst flash render BurstFlash.add(x, y, this.spreadSize / 4); // Play sound, but only for \"original\" shell, the one that was launched. // We don't want multiple sounds from pistil or streamer \"sub-shells\". // This can be detected by the presence of a comet. if (this.comet) { // Scale explosion sound based on current shell size and selected (max) shell size. // Shooting selected shell size will always sound the same no matter the selected size, // but when smaller shells are auto-fired, they will sound smaller. It doesn't sound great // when a value too small is given though, so instead of basing it on proportions, we just // look at the difference in size and map it to a range known to sound good. // The language of this project was translated into Chinese by Nianbroken const maxDiff = 2; const sizeDifferenceFromMaxSize = Math.min(maxDiff, shellSizeSelector() - this.shellSize); const soundScale = (1 - sizeDifferenceFromMaxSize / maxDiff) * 0.3 + 0.7; soundManager.playSound('burst', soundScale); } } } const BurstFlash = { active: [], _pool: [], _new() { return {} }, add(x, y, radius) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.radius = radius; this.active.push(instance); return instance; }, returnInstance(instance) { this._pool.push(instance); } }; // Helper to generate objects for storing active particles. // Particles are stored in arrays keyed by color (code, not name) for improved rendering performance. function createParticleCollection() { const collection = {}; COLOR_CODES_W_INVIS.forEach(color => { collection[color] = []; }); return collection; } // Star properties (WIP) // ----------------------- // transitionTime - how close to end of life that star transition happens const Star = { // Visual properties drawWidth: 3, airDrag: 0.98, airDragHeavy: 0.992, // Star particles will be keyed by color active: createParticleCollection(), _pool: [], _new() { return {}; }, add(x, y, color, angle, speed, life, speedOffX, speedOffY) { const instance = this._pool.pop() || this._new(); instance.visible = true; instance.heavy = false; instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed + (speedOffX || 0); instance.speedY = Math.cos(angle) * speed + (speedOffY || 0); instance.life = life; instance.fullLife = life; instance.spinAngle = Math.random() * PI_2; instance.spinSpeed = 0.8; instance.spinRadius = 0; instance.sparkFreq = 0; // ms between spark emissions instance.sparkSpeed = 1; instance.sparkTimer = 0; instance.sparkColor = color; instance.sparkLife = 750; instance.sparkLifeVariation = 0.25; instance.strobe = false; this.active[color].push(instance); return instance; }, // Public method for cleaning up and returning an instance back to the pool. // Language translation of this project into Chinese by Nianbroken returnInstance(instance) { // Call onDeath handler if available (and pass it current star instance) instance.onDeath && instance.onDeath(instance); // Clean up instance.onDeath = null; instance.secondColor = null; instance.transitionTime = 0; instance.colorChanged = false; // Add back to the pool. this._pool.push(instance); } }; const Spark = { // Visual properties drawWidth: 0, // set in `configDidUpdate()` airDrag: 0.9, // Star particles will be keyed by color active: createParticleCollection(), _pool: [], _new() { return {}; }, add(x, y, color, angle, speed, life) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed; instance.speedY = Math.cos(angle) * speed; instance.life = life; this.active[color].push(instance); return instance; }, // Public method for cleaning up and returning an instance back to the pool. returnInstance(instance) { // Add back to the pool. this._pool.push(instance); } }; const soundManager = { baseURL: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/', ctx: new (window.AudioContext || window.webkitAudioContext), sources: { lift: { volume: 1, playbackRateMin: 0.85, playbackRateMax: 0.95, fileNames: [ 'lift1.mp3', 'lift2.mp3', 'lift3.mp3' ] }, burst: { volume: 1, playbackRateMin: 0.8, playbackRateMax: 0.9, fileNames: [ 'burst1.mp3', 'burst2.mp3' ] }, burstSmall: { volume: 0.25, playbackRateMin: 0.8, playbackRateMax: 1, fileNames: [ 'burst-sm-1.mp3', 'burst-sm-2.mp3' ] }, crackle: { volume: 0.2, playbackRateMin: 1, playbackRateMax: 1, fileNames: ['crackle1.mp3'] }, crackleSmall: { volume: 0.3, playbackRateMin: 1, playbackRateMax: 1, fileNames: ['crackle-sm-1.mp3'] } }, preload() { const allFilePromises = []; function checkStatus(response) { if (response.status >= 200 && response.status < 300) { return response; } const customError = new Error(response.statusText); customError.response = response; throw customError; } const types = Object.keys(this.sources); types.forEach(type => { const source = this.sources[type]; const { fileNames } = source; const filePromises = []; fileNames.forEach(fileName => { const fileURL = this.baseURL + fileName; // Promise will resolve with decoded audio buffer. const promise = fetch(fileURL) .then(checkStatus) .then(response => response.arrayBuffer()) .then(data => new Promise(resolve => { this.ctx.decodeAudioData(data, resolve); })); filePromises.push(promise); allFilePromises.push(promise); }); Promise.all(filePromises) .then(buffers => { source.buffers = buffers; }); }); return Promise.all(allFilePromises); }, pauseAll() { this.ctx.suspend(); }, resumeAll() { // Play a sound with no volume for iOS. This 'unlocks' the audio context when the user first enables sound. this.playSound('lift', 0); // Chrome mobile requires interaction before starting audio context. // The sound toggle button is triggered on 'touchstart', which doesn't seem to count as a full // interaction to Chrome. I guess it needs a click? At any rate if the first thing the user does // is enable audio, it doesn't work. Using a setTimeout allows the first interaction to be registered. // Perhaps a better solution is to track whether the user has interacted, and if not but they try enabling // sound, show a tooltip that they should tap again to enable sound. setTimeout(() => { this.ctx.resume(); }, 250); }, // Private property used to throttle small burst sounds. _lastSmallBurstTime: 0, /** * Play a sound of `type`. Will randomly pick a file associated with type, and play it at the specified volume * and play speed, with a bit of random variance in play speed. This is all based on `sources` config. * * @param {string} type - The type of sound to play. * @param {?number} scale=1 - Value between 0 and 1 (values outside range will be clamped). Scales less than one * descrease volume and increase playback speed. This is because large explosions are * louder, deeper, and reverberate longer than small explosions. * Note that a scale of 0 will mute the sound. */ playSound(type, scale=1) { // Ensure `scale` is within valid range. scale = MyMath.clamp(scale, 0, 1); // Disallow starting new sounds if sound is disabled, app is running in slow motion, or paused. // Slow motion check has some wiggle room in case user doesn't finish dragging the speed bar // *all* the way back. if (!canPlaySoundSelector() || simSpeed < 0.95) { return; } // Throttle small bursts, since floral/falling leaves shells have a lot of them. if (type === 'burstSmall') { const now = Date.now(); if (now - this._lastSmallBurstTime < 20) { return; } this._lastSmallBurstTime = now; } const source = this.sources[type]; if (!source) { throw new Error(`Sound of type \"${type}\" doesn't exist.`); } const initialVolume = source.volume; const initialPlaybackRate = MyMath.random( source.playbackRateMin, source.playbackRateMax ); // Volume descreases with scale. const scaledVolume = initialVolume * scale; // Playback rate increases with scale. For this, we map the scale of 0-1 to a scale of 2-1. // So at a scale of 1, sound plays normally, but as scale approaches 0 speed approaches double. const scaledPlaybackRate = initialPlaybackRate * (2 - scale); const gainNode = this.ctx.createGain(); gainNode.gain.value = scaledVolume; const buffer = MyMath.randomChoice(source.buffers); const bufferSource = this.ctx.createBufferSource(); bufferSource.playbackRate.value = scaledPlaybackRate; bufferSource.buffer = buffer; bufferSource.connect(gainNode); gainNode.connect(this.ctx.destination); bufferSource.start(0); } }; // Kick things off. function setLoadingStatus(status) { document.querySelector('.loading-init__status').textContent = status; } // CodePen profile header doesn't need audio, just initialize. if (IS_HEADER) { init(); } else { // Allow status to render, then preload assets and start app. setLoadingStatus('Ê≠£Âú®ÁÇπÁáÉÂØºÁÅ´Á∫ø'); setTimeout(() => { soundManager.preload() .then( init, reason => { // Codepen preview doesn't like to load the audio, so just init to fix the preview for now. init(); // setLoadingStatus('Error Loading Audio'); return Promise.reject(reason); } ); }, 0); }"},{"title":"","date":"2023-01-06T01:29:22.838Z","updated":"2022-12-26T01:20:41.504Z","comments":true,"path":"assets/ba/config.json","permalink":"http://www.angforever.top/assets/ba/config.json","excerpt":"","text":"{\"draw_output\":\"image\",\"message_type\":\"command\",\"output_suffix\":\"{filename}\",\"is_tome\":false}"}],"posts":[{"title":"ÊòÇÊòÇbotÊåá‰ª§","slug":"ÊòÇÊòÇbotÊåá‰ª§","date":"2023-01-04T16:00:00.000Z","updated":"2023-01-12T08:08:08.866Z","comments":true,"path":"2023/01/05/ÊòÇÊòÇbotÊåá‰ª§/","link":"","permalink":"http://www.angforever.top/2023/01/05/%E6%98%82%E6%98%82bot%E6%8C%87%E4%BB%A4/","excerpt":"ÊòÇÊòÇbotÊåá‰ª§","text":"ÊòÇÊòÇbotÊåá‰ª§ ÂëΩ‰ª§[Pic_menu] ËèúÂçï ËèúÂçï 4 2 [AnimalVoice_Convert]ÂÖΩÈü≥Âä†ÂØÜ&#x2F;convert | Âê¶ | Áæ§ËÅä&#x2F;ÁßÅËÅä | ÂèëÈÄÅÈúÄË¶ÅÂä†ÂØÜÁöÑÊñáÂ≠ó |ÂÖΩÈü≥Ëß£ÂØÜ&#x2F;deconvert | Âê¶ | Áæ§ËÅä&#x2F;ÁßÅËÅä | ÂèëÈÄÅÈúÄË¶ÅËß£ÂØÜÁöÑÊñáÂ≠ó |ÂàáÂôú‰∏Ä‰∏ã&#x2F;cherulize | Âê¶ | Áæ§ËÅä&#x2F;ÁßÅËÅä | ÂèëÈÄÅÈúÄË¶ÅËß£ÂØÜÁöÑÊñáÂ≠ó |ÂàáÂôúÔΩû&#x2F;decherulize | Âê¶ | Áæ§ËÅä&#x2F;ÁßÅËÅä | ÂèëÈÄÅÈúÄË¶ÅËß£ÂØÜÁöÑÊñáÂ≠ó | [wallpaper]ÂèëÈÄÅÂ£ÅÁ∫∏Ëé∑Âèñ‰∏ÄÂº†Â£ÅÁ∫∏ ÂèëÈÄÅ ËøêÊ∞îÊ£ÄÊµã ÊâìÂºÄÈöèÊú∫Âá∫‰∏ÄÂº†Â£ÅÁ∫∏ ÈùûÈÖãËøò‰ºöÂà∑Âá∫Êù•È£éÊôØÂõæ apiÊù•Ëá™ http://api.iw233.cn/API/index.php food Ëé∑ÂèñÈ£üÁâ© sc + ÊêúÁ¥¢ÁõÆÊ†áÊêúÂõæ [nonebot-plugin-status]‚ú® NoneBot ÊúçÂä°Âô®Áä∂ÊÄÅÔºàCPU, Memory, Disk UsageÔºâÊü•ÁúãÊèí‰ª∂‚ú®:ÂêëÊú∫Âô®‰∫∫ÂèëÈÄÅÊà≥‰∏ÄÊà≥Ë°®ÊÉÖÂèåÂáªÊú∫Âô®‰∫∫Â§¥ÂÉèÊà≥‰∏ÄÊà≥ [nonebot_plugin_setu4]ÂÜÖÁΩÆÊï∞ÊçÆÂ∫ìÁöÑsetuÊèí‰ª∂: ÂëΩ‰ª§Â§¥: setu|Ëâ≤Âõæ|Ê∂©Âõæ|ÊÉ≥Ëâ≤Ëâ≤|Êù•‰ªΩËâ≤Ëâ≤|Êù•‰ªΩËâ≤Âõæ|ÊÉ≥Ê∂©Ê∂©|Â§öÊù•ÁÇπ|Êù•ÁÇπËâ≤Âõæ|Êù•Âº†setu|Êù•Âº†Ëâ≤Âõæ|Êù•ÁÇπËâ≤Ëâ≤|Ëâ≤Ëâ≤|Ê∂©Ê∂© (‰ªªÊÑè‰∏Ä‰∏™) Âº†Êï∞: 1 2 3 4 ... Âº†|‰∏™|‰ªΩ (ÂèØ‰∏çÂ°´, ÈªòËÆ§1) r18: ‰∏çÂ°´Âàô‰∏ç‰ºöÂá∫Áé∞r18ÂõæÁâá, Â°´‰∫Ü‰ºöÊ†πÊçÆr18Ê®°ÂºèÁÆ°ÁêÜ‰∏≠ÁöÑÊï∞ÊçÆÂà§Êñ≠ÊòØÂê¶ÂèØËøîÂõûr18ÂõæÁâá ÂÖ≥ÈîÆËØç: ‰ªªÊÑè (ÂèØ‰∏çÂ°´) ÂèÇËÄÉ (Á©∫Ê†ºÂèØÂéªÊéâ): setu 10Âº† r18 ÁôΩ‰∏ùsetu 10Âº† ÁôΩ‰∏ùsetu r18 ÁôΩ‰∏ùsetu ÁôΩ‰∏ùsetu [nonebot-plugin-drawer] ÁõÆÂâçÂõ†‰∏∫ÊñáÂøÉÊé•Âè£ÂéüÂõ†ÂÅúÊ≠¢‰ΩøÁî®Âü∫‰∫éÊñáÂøÉÂ§ßÊ®°ÂûãÁöÑAIÊú∫Âô®‰∫∫ÁîªÁîªÊèí‰ª∂: Ëß¶ÂèëËèúÂçïÂëΩ‰ª§ÔºöÁîªÁîªÂ∏ÆÂä© ÂΩìÂâçÊîØÊåÅ Âè§È£é Ê≤πÁîª Ê∞¥ÂΩ©Áîª Âç°ÈÄöÁîª ‰∫åÊ¨°ÂÖÉ ÊµÆ‰∏ñÁªò Ëí∏Ê±ΩÊ≥¢Ëâ∫ÊúØ low poly ÂÉèÁ¥†È£éÊ†º Ê¶ÇÂøµËâ∫ÊúØ Êú™Êù•‰∏ª‰πâ ËµõÂçöÊúãÂÖã ÂÜôÂÆûÈ£éÊ†º Ê¥õ‰∏ΩÂ°îÈ£éÊ†º Â∑¥Ê¥õÂÖãÈ£éÊ†º Ë∂ÖÁé∞ÂÆû‰∏ª‰πâ ‰∏ªË¶ÅÊìÖÈïøÈ£éÊôØÂÜôÊÑèÁîªÔºåËØ∑Â∞ΩÈáèÁªôÂÆöÊØîËæÉÊòéÁ°ÆÁöÑÊÑèË±° Â¶ÇÔºöÊ≤πÁîª Ê±ü‰∏äËêΩÊó•‰∏éÊôöÈúû „ÄåÂÖ¨Âºè„Äç&#x3D; ÂõæÁâá‰∏ª‰ΩìÔºåÁªÜËäÇËØçÔºå‰øÆÈ•∞ËØç apiÁî≥ËØ∑https://wenxin.baidu.com/younger/apiDetail?id=20008 [nonebot_plugin_weather_lite]‰ΩøÁî®wttr.inÁöÑÂ§©Ê∞îÊü•ËØ¢:ÂëΩ‰ª§Ôºö Ê≥®Ôºö 1.‰ª•‰∏ãÂ§©Ê∞îÂëΩ‰ª§ÂùáÂèØ‰ª•‰ΩøÁî®wttr„ÄÅweather„ÄÅtianqiÁ≠âÊïàÊõø‰ª£, 2.ÂüéÂ∏ÇÂêçÂèØ‰ª•‰ΩøÁî®ÂêÑÁßçËØ≠Ë®ÄÔºå‰æãÂ¶ÇBeijing„ÄÅPeking„ÄÅÂåó‰∫¨ÊòØÁ≠âÊïàÁöÑ„ÄÇ 3.ÊîØÊåÅÊü•ËØ¢ÂÖ®ÁêÉÂêÑÁßçÂú∞Âå∫„ÄÇ‰æãÂ¶ÇËé´ÊñØÁßë‰ªÄ‰πàÁöÑÈÉΩÂèØ‰ª•„ÄÇ &quot;Â§©Ê∞î ÂüéÂ∏ÇÂêç&quot; (ÂèØÈÄâÔºåÂ¶Ç‰∏çÁªôÂá∫Êú∫Âô®‰∫∫‰ºöÊèêÁ§∫Ëé∑Âèñ) &quot;Â§©Ê∞î ÂüéÂ∏ÇÂêç_format=v2&quot; &quot;Â§©Ê∞î ÂüéÂ∏ÇÂêç_format=v3&quot; ÊåáÂÆöËØ≠Ë®Ä: Â§©Ê∞î ÂüéÂ∏ÇÂêç_lang=ËØ≠Ë®Ä ËØ≠Ë®ÄÂèØÈÄâ‰∫éÔºö am ar af be bn ca da de el et fr fa hi hu ia id it lt mg nb nl oc pl pt-br ro ru ta tr th uk vi zh-cn zh-tw ÁîöËá≥ÊîØÊåÅÁúãÊúàÁõ∏Ôºö &quot;Â§©Ê∞î Moon&quot; Êõ¥Â§öÁî®Ê≥ïËØ∑ÂèÇËÄÉwttr.inÁöÑÊñáÊ°£ÔºÅÂú∞ÂùÄÔºöhttps://github.com/chubin/wttr.in [nonebot_plugin_fortune] Âç†Âçú‰∏Ä‰∏ã‰Ω†ÁöÑ‰ªäÊó•ËøêÂäøÔºÅüéâ ‰∏ÄËà¨ÊäΩÁ≠æÔºö‰ªäÊó•ËøêÂäø„ÄÅÊäΩÁ≠æ„ÄÅËøêÂäøÔºõ ÊåáÂÆö‰∏ªÈ¢òÊäΩÁ≠æÔºö[xxÊäΩÁ≠æ]Ôºå‰æãÂ¶ÇÔºöpcrÊäΩÁ≠æ„ÄÅholoÊäΩÁ≠æ„ÄÅÁ¢ßËìùÊäΩÁ≠æÔºõ [Áæ§ÁÆ°ÊàñÁæ§‰∏ªÊàñË∂ÖÁÆ°] ÈÖçÁΩÆÊäΩÁ≠æ‰∏ªÈ¢òÔºöËÆæÁΩÆ[ÂéüÁ•û/pcr/‰∏úÊñπ/vtb/xxx]Á≠æÔºöËÆæÁΩÆÁæ§ÊäΩÁ≠æ‰∏ªÈ¢òÔºõ ÈáçÁΩÆÔºàÊäΩÁ≠æÔºâ‰∏ªÈ¢òÔºöËÆæÁΩÆÁæ§ÊäΩÁ≠æ‰∏ªÈ¢ò‰∏∫ÈöèÊú∫Ôºõ ÊäΩÁ≠æËÆæÁΩÆÔºöÊü•ÁúãÂΩìÂâçÁæ§ÊäΩÁ≠æ‰∏ªÈ¢òÁöÑÈÖçÁΩÆÔºõ [Ë∂ÖÁÆ°] Âà∑Êñ∞ÊäΩÁ≠æ ÔºöÂÖ®Â±ÄÂç≥ÂàªÂà∑Êñ∞ÊäΩÁ≠æÔºåÈò≤Ê≠¢Ëøá0ÁÇπÊú™Âà∑Êñ∞Ôºõ ‰ªäÊó•ËøêÂäøÂ∏ÆÂä© ÔºöÊòæÁ§∫Êèí‰ª∂Â∏ÆÂä©ÊñáÊ°àÔºõ Êü•ÁúãÔºàÊäΩÁ≠æÔºâ‰∏ªÈ¢ò ÔºöÊòæÁ§∫ÂΩìÂâçÂ∑≤ÂêØÁî®‰∏ªÈ¢òÔºõ [HarukaBot bÁ´ôÊé®ÈÄÅ] ÔºàËØ∑Â∞ÜUIDÊõøÊç¢‰∏∫ÈúÄË¶ÅÊìç‰ΩúÁöÑBÁ´ôUIDÔºâ ÂÖ≥Èó≠ÂÖ®‰Ωì UIDÂºÄÂêØÂÖ®‰Ωì UIDÂºÄÂêØÂä®ÊÄÅ UIDÂÖ≥Èó≠Âä®ÊÄÅ UIDÂÖ≥Èó≠Áõ¥Êí≠ UIDÂºÄÂêØÁõ¥Êí≠ UIDÂÖ≥Èó≠ÊùÉÈôêÂºÄÂêØÊùÉÈôêÂÖ≥Ê≥® UIDÂèñÂÖ≥ UIDÂÖ≥Ê≥®ÂàóË°®Êú™ÊîπÈÖçÁΩÆÁæ§ËÅä‰∏≠ËØ∑@Êú∫Âô®‰∫∫‰ΩøÁî® [savor]ÂàÜÊûê + ÂõæÁâá ÂàÜÊûêÂõæÁâátag [pixiv_bot]ÁúãÁúã&lt;Á±ªÂûã&gt;Ê¶ú&lt;ËåÉÂõ¥&gt;ÔºöÊü•ÁúãpixivÊ¶úÂçï &lt;Á±ªÂûã&gt;ÂèØÁúÅÁï• Êù•&lt;Êï∞Èáè&gt;Âº†ÂõæÔºö‰ªéÊé®ËçêÊèíÁîªÈöèÊú∫ÊäΩÈÄâ‰∏ÄÂº†ÊèíÁîªÔºà&lt;Êï∞Èáè&gt;ÂèØÁúÅÁï•Ôºå‰∏ãÂêåÔºâ Êù•&lt;Êï∞Èáè&gt;Âº†&lt;ÂÖ≥ÈîÆÂ≠ó&gt;ÂõæÔºöÊêúÁ¥¢ÂÖ≥ÈîÆÂ≠óÔºå‰ªéÊêúÁ¥¢ÁªìÊûúÈöèÊú∫ÊäΩÈÄâ‰∏ÄÂº†ÊèíÁîª Á§∫‰æãÔºöÊù•Âº†ÂàùÈü≥„Éü„ÇØÂõæ„ÄÅÊù•‰∫îÂº†ÂàùÈü≥„Éü„ÇØÂõæ Êù•&lt;Êï∞Èáè&gt;Âº†&lt;Áî®Êà∑&gt;ËÄÅÂ∏àÁöÑÂõæÔºöÊêúÁ¥¢Áî®Êà∑Ôºå‰ªéÊèíÁîªÂàóË°®‰∏≠ÈöèÊú∫ÊäΩÈÄâ‰∏ÄÂº†ÊèíÁîª ÁúãÁúãÂõæ&lt;ÊèíÁîªID&gt;ÔºöÊü•ÁúãIDÂØπÂ∫îÁöÑÊèíÁîª Á§∫‰æãÔºöÁúãÁúãÂõæ114514 Êù•&lt;Êï∞Èáè&gt;Âº†ÁßÅÂÆ∂ËΩ¶Ôºö‰ªé‰π¶Á≠æ‰∏≠ÈöèÊú∫ÊäΩÈÄâ‰∏ÄÂº†ÊèíÁîªÔºàÂèëÈÄÅËÄÖÈúÄÁªëÂÆöPixivË¥¶Âè∑ÔºåÊàñËÄÖÂú®ÈÖçÁΩÆ‰∏≠ÊåáÂÆöÈªòËÆ§PixivË¥¶Âè∑Ôºâ /pixivbot bind &lt;pixiv_user_id&gt;ÔºöÁªëÂÆöPixivË¥¶Âè∑ÔºàÁî®‰∫éÈöèÊú∫‰π¶Á≠æÂäüËÉΩÔºâ /pixivbot unbindÔºöËß£ÁªëPixivË¥¶Âè∑ /pixivbot„ÄÅ/pixivbot helpÔºöÊü•ÁúãÂ∏ÆÂä© [face2cartoonpic]‰∫∫ÂÉèÂèòÊç¢ + ÂõæÁâá ÂèØ‰ª•ÂÆûÁé∞qqÁöÑÂèòËÑ∏ÂäüËÉΩ [maimaidx]‰ªäÊó•ËàûËêå Êü•Áúã‰ªäÂ§©ÁöÑËàûËêåËøêÂäø XXXmaimaiXXX‰ªÄ‰πà ÈöèÊú∫‰∏ÄÈ¶ñÊ≠å Èöè‰∏™[dx/Ê†áÂáÜ][ÁªøÈªÑÁ∫¢Á¥´ÁôΩ]&lt;ÈöæÂ∫¶&gt; ÈöèÊú∫‰∏ÄÈ¶ñÊåáÂÆöÊù°‰ª∂ÁöÑ‰πêÊõ≤ Êü•Ê≠å&lt;‰πêÊõ≤Ê†áÈ¢òÁöÑ‰∏ÄÈÉ®ÂàÜ&gt; Êü•ËØ¢Á¨¶ÂêàÊù°‰ª∂ÁöÑ‰πêÊõ≤ [ÁªøÈªÑÁ∫¢Á¥´ÁôΩ]id&lt;Ê≠åÊõ≤ÁºñÂè∑&gt; Êü•ËØ¢‰πêÊõ≤‰ø°ÊÅØÊàñË∞±Èù¢‰ø°ÊÅØ &lt;Ê≠åÊõ≤Âà´Âêç&gt;ÊòØ‰ªÄ‰πàÊ≠å Êü•ËØ¢‰πêÊõ≤Âà´ÂêçÂØπÂ∫îÁöÑ‰πêÊõ≤ ÂÆöÊï∞Êü•Ê≠å &lt;ÂÆöÊï∞&gt; Êü•ËØ¢ÂÆöÊï∞ÂØπÂ∫îÁöÑ‰πêÊõ≤ ÂÆöÊï∞Êü•Ê≠å &lt;ÂÆöÊï∞‰∏ãÈôê&gt; &lt;ÂÆöÊï∞‰∏äÈôê&gt; ÂàÜÊï∞Á∫ø &lt;ÈöæÂ∫¶+Ê≠åÊõ≤id&gt; &lt;ÂàÜÊï∞Á∫ø&gt; ËØ¶ÊÉÖËØ∑ËæìÂÖ•‚ÄúÂàÜÊï∞Á∫ø Â∏ÆÂä©‚ÄùÊü•Áúã","categories":[{"name":"ÊòÇÊòÇbot","slug":"ÊòÇÊòÇbot","permalink":"http://www.angforever.top/categories/%E6%98%82%E6%98%82bot/"}],"tags":[{"name":"botÁõ∏ÂÖ≥","slug":"botÁõ∏ÂÖ≥","permalink":"http://www.angforever.top/tags/bot%E7%9B%B8%E5%85%B3/"}]},{"title":"Webgames","slug":"Webgames","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-12T08:19:28.464Z","comments":true,"path":"2023/01/01/Webgames/","link":"","permalink":"http://www.angforever.top/2023/01/01/Webgames/","excerpt":"","text":"Catch That Cat! ADarkroom ‰º†ÁÅ´","categories":[],"tags":[{"name":"webgames","slug":"webgames","permalink":"http://www.angforever.top/tags/webgames/"}]}],"categories":[{"name":"ÊòÇÊòÇbot","slug":"ÊòÇÊòÇbot","permalink":"http://www.angforever.top/categories/%E6%98%82%E6%98%82bot/"}],"tags":[{"name":"botÁõ∏ÂÖ≥","slug":"botÁõ∏ÂÖ≥","permalink":"http://www.angforever.top/tags/bot%E7%9B%B8%E5%85%B3/"},{"name":"webgames","slug":"webgames","permalink":"http://www.angforever.top/tags/webgames/"}]}